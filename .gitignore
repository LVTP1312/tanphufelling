--// TanPhu Full UI + Helper Tab (ESP Player + Timer ESP + Feeling Steal) + Logger chạy ngầm

--======================================================
-- UI Services
--======================================================
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

-- Toggle UI bằng phím LeftControl
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.LeftControl then
        gui.Enabled = not gui.Enabled
    end
end)

--======================================================
-- ScreenGui
--======================================================
local gui = Instance.new("ScreenGui")
gui.Name = "TanPhuUI"
gui.ResetOnSpawn = false
gui.Parent = game.CoreGui
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main Frame
local main = Instance.new("Frame")
main.Parent = gui
main.Size = UDim2.new(0, 650, 0, 400)
main.Position = UDim2.new(0.5, -325, 0.5, -200)
main.BackgroundColor3 = Color3.fromRGB(20, 40, 80)
main.BackgroundTransparency = 0.2
main.BorderSizePixel = 0
Instance.new("UICorner", main).CornerRadius = UDim.new(0, 12)

-- Top Bar
local topBar = Instance.new("Frame")
topBar.Parent = main
topBar.Size = UDim2.new(1, 0, 0, 40)
topBar.BackgroundColor3 = Color3.fromRGB(10, 20, 60)
topBar.BackgroundTransparency = 0.1
topBar.BorderSizePixel = 0
Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 12)

local title = Instance.new("TextLabel")
title.Parent = topBar
title.Size = UDim2.new(1, -40, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.Text = "TanPhu"
title.Font = Enum.Font.GothamBold
title.TextSize = 22
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.BackgroundTransparency = 1
title.TextXAlignment = Enum.TextXAlignment.Left

local closeBtn = Instance.new("TextButton")
closeBtn.Parent = topBar
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -35, 0.5, -15)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 18
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeBtn.AutoButtonColor = true
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

closeBtn.MouseButton1Click:Connect(function()
    gui.Enabled = not gui.Enabled
end)


-- ===== Tiny Avatar Toggle Button (left edge) =====
do
    local AVATAR_FILE = "TanPhuHub/avatar.png"  -- bạn có thể đặt ảnh vào đây để dùng getcustomasset
    local FALLBACK_IMG = "rbxassetid://7072717697" -- fallback nếu không có ảnh cục bộ
    local img = FALLBACK_IMG
    pcall(function()
        if getcustomasset and isfile and isfile(AVATAR_FILE) then
            img = getcustomasset(AVATAR_FILE)
        end
    end)

    local avatarBtn = Instance.new("ImageButton")
    avatarBtn.Name = "TP_AvatarToggle"
    avatarBtn.Size = UDim2.new(0, 48, 0, 48)
    avatarBtn.Position = UDim2.new(0, 10, 0.5, -24)
    avatarBtn.BackgroundTransparency = 1
    avatarBtn.Image = img
    avatarBtn.Parent = gui

    local uic = Instance.new("UICorner", avatarBtn)
    uic.CornerRadius = UDim.new(1, 0)
    local stroke = Instance.new("UIStroke", avatarBtn)
    stroke.Thickness = 1.2
    stroke.Color = Color3.fromRGB(0, 170, 255)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    avatarBtn.MouseButton1Click:Connect(function()
        gui.Enabled = not gui.Enabled
    end)
end
-- ===============================================================
-- Sidebar
local sidebar = Instance.new("Frame")
sidebar.Parent = main
sidebar.Size = UDim2.new(0, 160, 1, -40)
sidebar.Position = UDim2.new(0, 0, 0, 40)
sidebar.BackgroundColor3 = Color3.fromRGB(15, 30, 60)
sidebar.BackgroundTransparency = 0.2
sidebar.BorderSizePixel = 0

local sideLayout = Instance.new("UIListLayout", sidebar)
sideLayout.Padding = UDim.new(0, 6)
sideLayout.FillDirection = Enum.FillDirection.Vertical

-- Content
local content = Instance.new("Frame")
content.Parent = main
content.Size = UDim2.new(1, -180, 1, -60)
content.Position = UDim2.new(0, 170, 0, 50)
content.BackgroundColor3 = Color3.fromRGB(25, 50, 100)
content.BackgroundTransparency = 0.2
content.BorderSizePixel = 0
Instance.new("UICorner", content).CornerRadius = UDim.new(0, 10)

--======================================================
-- Sidebar Buttons
--======================================================
local sideButtons = {"Main", "Stealer (New)", "Helper", "Player", "Finder", "Server", "Discord"}
local selectedButton
local contentTabs = {}

for _, txt in ipairs(sideButtons) do
    local btn = Instance.new("TextButton")
    btn.Parent = sidebar
    btn.Size = UDim2.new(1, -12, 0, 35)
    btn.Position = UDim2.new(0, 6, 0, 0)
    btn.Text = txt
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(200, 200, 200)
    btn.BackgroundColor3 = Color3.fromRGB(30, 60, 120)
    btn.BackgroundTransparency = 0.3
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

    local tabContent = Instance.new("Frame")
    tabContent.Parent = content
    tabContent.Size = UDim2.new(1, 0, 1, 0)
    tabContent.BackgroundTransparency = 1
    tabContent.Visible = false
    contentTabs[txt] = tabContent

    btn.MouseButton1Click:Connect(function()
        if selectedButton then
            TweenService:Create(selectedButton, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(30, 60, 120),
                TextColor3 = Color3.fromRGB(200, 200, 200)
            }):Play()
        end
        selectedButton = btn
        TweenService:Create(btn, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(0, 170, 255),
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()

        for _, frame in pairs(contentTabs) do
            frame.Visible = false
        end
        tabContent.Visible = true
    end)

    -- Default Helper
    if txt == "Helper" then
        btn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        selectedButton = btn
        tabContent.Visible = true
    end
end


-- ===== Save / Load Settings buttons at bottom of sidebar =====
do
    local function makeBtn(txt)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(1, -12, 0, 30)
        b.Position = UDim2.new(0, 6, 1, -36)
        b.Text = txt
        b.Font = Enum.Font.GothamSemibold
        b.TextSize = 13
        b.TextColor3 = Color3.fromRGB(255,255,255)
        b.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
        b.AutoButtonColor = true
        Instance.new("UICorner", b).CornerRadius = UDim.new(0, 8)
        return b
    end
    local saveBtn = makeBtn("Save Settings")
    saveBtn.Parent = sidebar
    local loadBtn = makeBtn("Load Settings")
    loadBtn.Parent = sidebar
    loadBtn.Position = UDim2.new(0, 6, 1, -70)

    saveBtn.MouseButton1Click:Connect(function() pcall(TP_SaveSettings, true) end)
    loadBtn.MouseButton1Click:Connect(function() pcall(TP_LoadSettings, true) end)
end
-- ==================================================================
--======================================================
-- Toggle Builder
--======================================================
local function createToggle(parent, text, description, order)
    local frame = Instance.new("Frame")
    frame.Parent = parent
    frame.Size = UDim2.new(1, -20, 0, 50)
    frame.BackgroundColor3 = Color3.fromRGB(40, 80, 160)
    frame.BackgroundTransparency = 0.2
    frame.BorderSizePixel = 0
    frame.Position = UDim2.new(0, 10, 0, (order - 1) * 55)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

    local label = Instance.new("TextLabel")
    label.Parent = frame
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.Text = text .. (description ~= "" and ("\n" .. description) or "")
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextColor3 = Color3.fromRGB(230, 230, 230)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.BackgroundTransparency = 1

    local toggle = Instance.new("TextButton")
    toggle.Parent = frame
    toggle.Size = UDim2.new(0, 45, 0, 22)
    toggle.Position = UDim2.new(1, -60, 0.5, -11)
    toggle.Text = ""
    toggle.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    toggle.AutoButtonColor = false
    Instance.new("UICorner", toggle).CornerRadius = UDim.new(1, 0)

    local knob = Instance.new("Frame")
    knob.Parent = toggle
    knob.Size = UDim2.new(0, 20, 0, 20)
    knob.Position = UDim2.new(0, 1, 0, 1)
    knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)

    local state = false
    local callback = nil

    toggle.MouseButton1Click:Connect(function()
        state = not state
        if state then
            TweenService:Create(toggle, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 170, 255)}):Play()
            TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(1, -21, 0, 1)}):Play()
        else
            TweenService:Create(toggle, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(180, 180, 180)}):Play()
            TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(0, 1, 0, 1)}):Play()
        end
        if callback then
            callback(state)
        end
    end)

    return {
        Frame = frame,
        SetCallback = function(fn)
            callback = fn
        end
    }
end


-- ===== Settings Persist: Save/Load + Toggle Registry =====
local HttpService = game:GetService("HttpService")
getgenv().TanPhuSettings = getgenv().TanPhuSettings or { toggles = {}, _autosave = true }
local TP_REG = {}
local SETTINGS_DIR = "TanPhuHub"
local SETTINGS_PATH = SETTINGS_DIR .. "/settings.json"

local function TP_SaveSettings(notify)
    local payload = { toggles = getgenv().TanPhuSettings.toggles or {} }
    local ok, json = pcall(function() return HttpService:JSONEncode(payload) end)
    if ok and writefile then
        pcall(function()
            if isfolder and not isfolder(SETTINGS_DIR) then makefolder(SETTINGS_DIR) end
            writefile(SETTINGS_PATH, json)
        end)
    end
    if notify then print("[TanPhu] Saved settings to " .. SETTINGS_PATH) end
end

local function TP_LoadSettings(notify)
    local data = nil
    if readfile and isfile and isfile(SETTINGS_PATH) then
        local ok1, content = pcall(readfile, SETTINGS_PATH)
        if ok1 then
            local ok2, tbl = pcall(function() return HttpService:JSONDecode(content) end)
            if ok2 and type(tbl)=="table" then data = tbl end
        end
    end
    data = data or { toggles = getgenv().TanPhuSettings.toggles or {} }
    for _, item in ipairs(TP_REG) do
        local desired = data.toggles and data.toggles[item.key]
        if desired ~= nil and item.widget and item.widget.ApplyState then
            item.widget.ApplyState(desired)
        end
    end
    if notify then print("[TanPhu] Loaded settings") end
end

-- Wrap createToggle để đăng ký & thêm ApplyState
local _orig_createToggle = createToggle
createToggle = function(parent, text, description, order)
    local w = _orig_createToggle(parent, text, description, order)
    -- tìm Toggle button & knob để điều khiển UI
    local toggleBtn, knob = nil, nil
    for _, ch in ipairs(w.Frame:GetChildren()) do
        if ch:IsA("TextButton") then
            toggleBtn = ch
            knob = ch:FindFirstChildWhichIsA("Frame")
        end
    end
    local _state, _usercb = false, nil
    local _origSet = w.SetCallback
    w.SetCallback = function(fn)
        _usercb = fn
        _origSet(function(s)
            _state = s
            getgenv().TanPhuSettings.toggles[text] = s
            if _usercb then _usercb(s) end
            TP_SaveSettings(false) -- autosave mỗi lần đổi
        end)
    end
    function w.ApplyState(s)
        s = not not s
        if _state == s then return end
        _state = s
        getgenv().TanPhuSettings.toggles[text] = s
        if toggleBtn and knob then
            if s then
                TweenService:Create(toggleBtn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0,170,255)}):Play()
                TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(1, -21, 0, 1)}):Play()
            else
                TweenService:Create(toggleBtn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(180,180,180)}):Play()
                TweenService:Create(knob, TweenInfo.new(0.2), {Position = UDim2.new(0, 1, 0, 1)}):Play()
            end
        end
        if _usercb then _usercb(s) end
    end
    table.insert(TP_REG, {key = text, widget = w})
    return w
end

-- Tự load sau khi các toggle tạo xong
task.defer(function()
    task.wait(0.6)
    TP_LoadSettings(false)
end)

-- Giữ khi qua server (queue_on_teleport nếu có)
do
    local q = queue_on_teleport or (syn and syn.queue_on_teleport)
    if q and readfile and isfile and isfile(SETTINGS_PATH) then
        local ok, content = pcall(readfile, SETTINGS_PATH)
        if ok and type(content)=="string" then
            local esc = content:gsub("\\", "\\\\"):gsub("'", "\\'")
            q(("pcall(function() local HttpService=game:GetService('HttpService'); getgenv().TanPhuSettings = HttpService:JSONDecode('%s') end)"):format(esc))
        end
    end
end
-- ================================================================
--======================================================
-- Helper Tab
--======================================================
local helperTab = contentTabs["Helper"]

-- ESP Player
local playerESPEnabled = false
local espConnections = {}
local function togglePlayerESP(state)
    playerESPEnabled = state
    if state then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(0, 0, 255)
                highlight.FillTransparency = 0.7
                highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                highlight.Parent = plr.Character

                local bb = Instance.new("BillboardGui")
                bb.Name = "ESP_Name"
                bb.Adornee = plr.Character:FindFirstChild("Head")
                bb.Size = UDim2.new(0, 100, 0, 20)
                bb.StudsOffset = Vector3.new(0, 2, 0)
                bb.AlwaysOnTop = true
                bb.Parent = plr.Character

                local tl = Instance.new("TextLabel")
                tl.Size = UDim2.new(1, 0, 1, 0)
                tl.BackgroundTransparency = 1
                tl.Font = Enum.Font.GothamBold
                tl.Text = plr.Name
                tl.TextSize = 14
                tl.TextColor3 = Color3.fromRGB(0, 170, 255)
                tl.Parent = bb
            end
        end
        espConnections[#espConnections+1] = Players.PlayerAdded:Connect(function(plr)
            plr.CharacterAdded:Connect(function(char)
                if playerESPEnabled then
                    local highlight = Instance.new("Highlight")
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.FillTransparency = 0.7
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                    highlight.Parent = char

                    local bb = Instance.new("BillboardGui")
                    bb.Name = "ESP_Name"
                    bb.Adornee = char:FindFirstChild("Head")
                    bb.Size = UDim2.new(0, 100, 0, 20)
                    bb.StudsOffset = Vector3.new(0, 2, 0)
                    bb.AlwaysOnTop = true
                    bb.Parent = char

                    local tl = Instance.new("TextLabel")
                    tl.Size = UDim2.new(1, 0, 1, 0)
                    tl.BackgroundTransparency = 1
                    tl.Font = Enum.Font.GothamBold
                    tl.Text = plr.Name
                    tl.TextSize = 14
                    tl.TextColor3 = Color3.fromRGB(0, 170, 255)
                    tl.Parent = bb
                end
            end)
        end)
    else
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Character then
                if plr.Character:FindFirstChildOfClass("Highlight") then
                    plr.Character:FindFirstChildOfClass("Highlight"):Destroy()
                end
                if plr.Character:FindFirstChild("ESP_Name") then
                    plr.Character:FindFirstChild("ESP_Name"):Destroy()
                end
            end
        end
        for _, con in ipairs(espConnections) do
            con:Disconnect()
        end
        espConnections = {}
    end
end

local playerESPToggle = createToggle(helperTab, "ESP Player", "Highlight & tên người chơi", 1)
playerESPToggle.SetCallback(togglePlayerESP)

-- ESP Timeline (nhỏ gọn, chữ trắng)
local _tp_timeline_folder = Instance.new("Folder")
_tp_timeline_folder.Name = "TP_PlotTimeline"
_tp_timeline_folder.Parent = LocalPlayer:WaitForChild("PlayerGui")

local _tp_timeline_active = {}
local _tp_timeline_conn_added = nil
local _tp_timeline_conn_render = nil

local function _tp_attach_timeline(plot)
    if _tp_timeline_active[plot] then return end
    local rem = plot:FindFirstChild("RemainingTime", true)
    local main = plot:FindFirstChild("Main", true) or plot:FindFirstChildWhichIsA("BasePart", true)
    if not rem or not main then return end

    local bb = Instance.new("BillboardGui")
    bb.Name = "TP_Timeline"
    bb.Adornee = main
    bb.Size = UDim2.new(0, 90, 0, 32)
    bb.StudsOffset = Vector3.new(0, 5, 0)
    bb.AlwaysOnTop = true
    bb.Parent = _tp_timeline_folder

    local tl = Instance.new("TextLabel", bb)
    tl.Size = UDim2.new(1, 0, 1, 0)
    tl.BackgroundTransparency = 1
    tl.Font = Enum.Font.Gotham
    tl.TextScaled = true
    tl.TextColor3 = Color3.fromRGB(255,255,255)
    tl.TextStrokeTransparency = 0.5

    _tp_timeline_active[plot] = {Gui = bb, Label = tl, Rem = rem}
end

local function _tp_clear_timeline()
    for plot, data in pairs(_tp_timeline_active) do
        if data.Gui and data.Gui.Parent then data.Gui:Destroy() end
    end
    _tp_timeline_active = {}
end

local function _tp_enable_timeline()
    -- attach existing plotblocks
    for _, m in ipairs(Workspace:GetDescendants()) do
        if m:IsA("Model") and m.Name == "PlotBlock" then
            pcall(function() _tp_attach_timeline(m) end)
        end
    end
    -- watch new ones
    _tp_timeline_conn_added = Workspace.DescendantAdded:Connect(function(m)
        if m:IsA("Model") and m.Name == "PlotBlock" then
            pcall(function() _tp_attach_timeline(m) end)
        end
    end)
    -- render update
    _tp_timeline_conn_render = RunService.RenderStepped:Connect(function()
        for plot, data in pairs(_tp_timeline_active) do
            if data.Rem and data.Rem.Parent then
                local n = tonumber(string.match(tostring(data.Rem.Text or ""), "(%d+)"))
                if n and n > 0 then
                    data.Label.Text = tostring(n) .. "s"
                    data.Gui.Enabled = true
                else
                    if data.Gui then data.Gui.Enabled = false end
                end
            else
                if data.Gui then data.Gui.Enabled = false end
            end
        end
    end)
end

local function _tp_disable_timeline()
    if _tp_timeline_conn_added then _tp_timeline_conn_added:Disconnect() _tp_timeline_conn_added = nil end
    if _tp_timeline_conn_render then _tp_timeline_conn_render:Disconnect() _tp_timeline_conn_render = nil end
    _tp_clear_timeline()
end

-- Toggle trong Helper (order = 2 hoặc tùy bạn)
createToggle(contentTabs["Helper"], "ESP Timeline", "Hiện timer plot (trắng nhỏ)", 2).SetCallback(function(state)
    if state then _tp_enable_timeline() else _tp_disable_timeline() end
end)

-- Feeling Steal (load/kill)
local _tp_steal_thread = nil
local _tp_steal_toggle = createToggle(contentTabs["Helper"], "Feeling Steal", "Auto steal (load/kill)", 3)

_tp_steal_toggle.SetCallback(function(state)
    if state then
        if _tp_steal_thread then task.cancel(_tp_steal_thread) _tp_steal_thread = nil end
        _tp_steal_thread = task.spawn(function()
            local ok, err = pcall(function()
                local code = game:HttpGet("https://api.luarmor.net/files/v3/loaders/a3e13a4a85ac4c2da17a6baab051ee1b.lua")
                local fn = loadstring(code)
                if fn then fn() end
            end)
            if not ok then warn("[Feeling Steal] load error:", err) end
        end)
    else
        -- cố gắng kill thread; nếu script remote tạo connection riêng thì không chắc 100% dừng hết
        if _tp_steal_thread then
            task.cancel(_tp_steal_thread)
            _tp_steal_thread = nil
        end
        warn("[Feeling Steal] Toggle off: đã cancel thread (nếu script remote vẫn chạy, cần reload game để dọn sạch).")
    end
end)

--======================================================
-- ESP Pets (Brainrot) - loose name match anywhere + white/black UI
--======================================================
do
    -- Danh sách pet cần hiện
    local _pet_rules = {
        { k = "graipuss medussi",      min = 10_000_000,   max = 20_000_000   },
        { k = "la grande combinasion", min = 10_000_000,   max = 300_000_000  },
        { k = "los combinasionas",     min = 15_000_000,   max = 400_000_000  },
        { k = "nuclearo dinossauro",   min = 15_000_000,   max = 300_000_000  },
        { k = "los hotspotsitos",      min = 20_000_000,   max = 400_000_000  },
        { k = "garama and madundung",  min = 50_000_000,   max = 2_000_000_000},
    }

    local function _norm(s) return tostring(s or ""):lower() end

    local function _get_rule_hit_in_tree(root)
        -- Trả về (rule, hitText) nếu thấy tên ở Name hoặc trong TextLabel/StringValue
        local nameL = _norm(root.Name)
        for _,r in ipairs(_pet_rules) do
            if nameL:find(r.k, 1, true) then return r, root.Name end
        end
        local ok, descs = pcall(root.GetDescendants, root)
        if ok and type(descs)=="table" then
            for i=1,#descs do
                local d = descs[i]
                -- check name
                local dn = _norm(d.Name)
                for _,r in ipairs(_pet_rules) do
                    if dn:find(r.k, 1, true) then return r, d.Name end
                end
                -- check text value
                if d:IsA("TextLabel") or d:IsA("TextButton") then
                    local t = _norm(d.Text)
                    for _,r in ipairs(_pet_rules) do
                        if t:find(r.k, 1, true) then return r, d.Text end
                    end
                elseif d:IsA("StringValue") then
                    local v = _norm(d.Value)
                    for _,r in ipairs(_pet_rules) do
                        if v:find(r.k, 1, true) then return r, d.Value end
                    end
                end
            end
        end
        return nil
    end

    -- Parse $/s
    local function _parse_mps(val)
        if typeof(val) == "number" then return val end
        local s = _norm(val)
        local num = tonumber((s:match("([%d%.]+)")) or "0") or 0
        if s:find("b",1,true) then num = num * 1e9
        elseif s:find("m",1,true) then num = num * 1e6
        elseif s:find("k",1,true) then num = num * 1e3 end
        return math.floor(num + 0.5)
    end
    local function _text_is_per_sec(txt)
        local s = _norm(txt)
        return s:find("/s",1,true) or s:find("per%s*sec") or s:find("per%s*second")
    end
    local _deny = {"offline","cash","total","bank","balance","wallet","coins","gems","price","cost","buy","sell","collect","collected"}
    local function _has_token(s, toks)
        s = _norm(s)
        for _,t in ipairs(toks) do if s:find(t,1,true) then return true end end
        return false
    end

    local function _collect_prices(container)
        local list = {}
        local ok, descs = pcall(container.GetDescendants, container)
        if not ok or type(descs) ~= "table" then return list end
        for i=1,#descs do
            local d = descs[i]
            local nm_l = _norm(d.Name)
            if not _has_token(nm_l, _deny) then
                if d:IsA("TextLabel") or d:IsA("TextButton") then
                    local t = d.Text or ""
                    if t ~= "" and _text_is_per_sec(t) and not _has_token(t, _deny) then
                        local n = _parse_mps(t); if n > 0 then list[#list+1] = n end
                    end
                elseif d:IsA("StringValue") then
                    local v = d.Value
                    if type(v)=="string" and _text_is_per_sec(v) and not _has_token(v,_deny) then
                        local n = _parse_mps(v); if n > 0 then list[#list+1] = n end
                    end
                elseif d:IsA("NumberValue") or d:IsA("IntValue") then
                    local n = tonumber(d.Value) or 0
                    if n > 0 then list[#list+1] = n end
                end
            end
        end
        return list
    end

    local function _fmt_short(n)
        n = tonumber(n) or 0
        if n >= 1e9 then return ("$%.2fB/s"):format(n/1e9):gsub("%.?0+B","B")
        elseif n >= 1e6 then return ("$%.2fM/s"):format(n/1e6):gsub("%.?0+M","M")
        elseif n >= 1e3 then return ("$%.2fK/s"):format(n/1e3):gsub("%.?0+K","K")
        else return ("$%d/s"):format(n) end
    end

    local petESPEnabled = false
    local petESPItems = {}
    local addedConn

    local function _cleanup_one(m)
        local rec = petESPItems[m]
        if rec then
            if rec.hl and rec.hl.Parent then rec.hl:Destroy() end
            if rec.gui and rec.gui.Parent then rec.gui:Destroy() end
            petESPItems[m] = nil
        end
    end

    local function _attach_one(model)
        if petESPItems[model] then return end

        -- 1) Tên trùng ở bất kỳ đâu trong model?
        local rule, hitText = _get_rule_hit_in_tree(model)
        if not rule then return end

        -- 2) BasePart để bám label
        local adornee = model:FindFirstChild("Head") or model:FindFirstChildWhichIsA("BasePart", true)
        if not adornee then return end

        -- 3) Lấy giá (nếu có) – KHÔNG bắt buộc
        local prices = {}
        local function add(src)
            if not src then return end
            local ok, list = pcall(_collect_prices, src)
            if ok and type(list)=="table" then for i=1,#list do prices[#prices+1]=list[i] end end
        end
        add(model); add(model.Parent)
        table.sort(prices)

        -- 4) Highlight + label trắng–đen
        local hl = Instance.new("Highlight")
        hl.FillColor = Color3.fromRGB(255,255,255)
        hl.FillTransparency = 0.9
        hl.OutlineColor = Color3.fromRGB(255,255,255)
        hl.OutlineTransparency = 0.25
        hl.Parent = model

        local bb = Instance.new("BillboardGui")
        bb.Name = "TP_PetESP"
        bb.Adornee = adornee
        bb.Size = UDim2.new(0, 120, 0, 24)
        bb.StudsOffset = Vector3.new(0, 3.5, 0)
        bb.AlwaysOnTop = true
        bb.LightInfluence = 0
        bb.Parent = model

        local holder = Instance.new("Frame")
        holder.Parent = bb
        holder.Size = UDim2.new(1, 0, 1, 0)
        holder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        holder.BackgroundTransparency = 0.25
        holder.BorderSizePixel = 0
        Instance.new("UICorner", holder).CornerRadius = UDim.new(0, 6)

        local tl = Instance.new("TextLabel")
        tl.Parent = holder
        tl.Size = UDim2.new(1, -10, 1, -2)
        tl.Position = UDim2.new(0, 5, 0, 1)
        tl.BackgroundTransparency = 1
        tl.Font = Enum.Font.GothamSemibold
        tl.TextScaled = true
        tl.TextXAlignment = Enum.TextXAlignment.Center
        tl.TextYAlignment = Enum.TextYAlignment.Center
        tl.TextColor3 = Color3.fromRGB(255,255,255)
        tl.TextStrokeColor3 = Color3.fromRGB(0,0,0)
        tl.TextStrokeTransparency = 0
        local tsc = Instance.new("UITextSizeConstraint")
        tsc.Parent = tl
        tsc.MinTextSize = 10
        tsc.MaxTextSize = 18

        -- 5) Text hiển thị: tên (ưu tiên hitText) + giá nếu đọc được
        local nameText = tostring(hitText or model.Name)
        local tag = nameText
        if #prices >= 2 then
            tag = ("%s  (%s → %s)"):format(nameText, _fmt_short(prices[1]), _fmt_short(prices[#prices]))
        elseif #prices == 1 then
            tag = ("%s  (%s)"):format(nameText, _fmt_short(prices[1]))
        end
        tl.Text = tag

        model.AncestryChanged:Connect(function(_, parent)
            if not parent then _cleanup_one(model) end
        end)

        petESPItems[model] = {hl = hl, gui = bb}
    end

    local function _enable_pet_esp()
        for _,m in ipairs(Workspace:GetDescendants()) do
            if m:IsA("Model") then pcall(_attach_one, m) end
        end
        addedConn = Workspace.DescendantAdded:Connect(function(inst)
            if petESPEnabled and inst:IsA("Model") then pcall(_attach_one, inst) end
        end)
    end

    local function _disable_pet_esp()
        if addedConn then addedConn:Disconnect() addedConn=nil end
        for m,_ in pairs(petESPItems) do _cleanup_one(m) end
    end

    local petESPToggle = createToggle(contentTabs["Helper"], "ESP Pets (Brainrot)", "Highlight pet + Money/s", 4)
    petESPToggle.SetCallback(function(state)
        petESPEnabled = state
        if state then _enable_pet_esp() else _disable_pet_esp() end
    end)
end

--======================================================
-- Player Tab
--======================================================
local playerTab = contentTabs["Player"]

-- Biến Infinite Jump

-- ===== Player > speed boost rebirth 4 =====

-- ===== Player > fix fps akun =====
local fixfpsThread = nil

local fixfpsToggle = createToggle(playerTab, "fix fps akun", "Giảm lag, tăng FPS", 3)
fixfpsToggle.SetCallback(function(state)
    if state then
        if fixfpsThread then task.cancel(fixfpsThread) end
        fixfpsThread = task.spawn(function()
local ws = game:GetService("Workspace")

local function nuke(obj)
    if obj and obj:IsA("Accessory") then
        pcall(function() obj:Destroy() end)
    end
end

for _, v in ipairs(ws:GetDescendants()) do
    nuke(v)
end

ws.DescendantAdded:Connect(function(inst)
    nuke(inst)
end)

getgenv().On = false
if getgenv().On == false then
    return
end

local p  = game:GetService("Players")
local l  = p.LocalPlayer
local bp = l.Backpack
local c  = l.Character or workspace:WaitForChild(l.Name)
local h  = c:FindFirstChildOfClass("Humanoid") or c:WaitForChild("Humanoid")
local tool = bp:FindFirstChildOfClass("Tool")
local rs = game:GetService("RunService")

while task.wait() do
    if getgenv().On == false then
        break
    end
    h:EquipTool(tool)
    task.wait()
end

        end)
    else
        if fixfpsThread then
            task.cancel(fixfpsThread)
            fixfpsThread = nil
        end
    end
end)
-- ======================================================

local _tp_hybrid_obj = nil

local function TP_BuildHybridGrapple(parentGui)
--======================================================
-- HYBRID GRAPPLE — Q toggle, Ctrl+Q panel (workspace rope index)
--======================================================
do
    local Players = game:GetService('Players')
    local UIS = game:GetService('UserInputService')
    local CAS = game:GetService('ContextActionService')
    local RS = game:GetService('RunService')

    local LocalPlayer = Players.LocalPlayer

    --================= CONFIG =================
    local FORCE_TOOL_NAME = 'Grapple Hook'
    local AUTO_EQUIP = true

    local SPEED_MIN, SPEED_MAX, SPEED_STEP = 40, 320, 5
    local MAX_SPEED = 150 -- bạn có thể đổi mặc định ở đây
    local EFF_SPEED = 150
    local EFF_MIN = 70
    local RAMP_UP = 35
    local RAMP_DOWN = 220
    local BLEND = 0.55
    local ONLY_FLAT = true
    local CAM_WEIGHT = 0.9
    local MOVE_WEIGHT = 0.8

    local HOOK_ACTIVATE_MIN, HOOK_ACTIVATE_MAX = 0.28, 0.75
    local HOOK_ACTIVATE_UP, HOOK_ACTIVATE_DOWN = 0.12, 0.05

    local SNAP_POS_THRESHOLD = 3.2
    local SNAP_VEL_THRESHOLD = 45.0
    local SNAP_COOLDOWN = 0.30

    local AIR_MULTIPLIER = 0.6
    local RAY_LENGTH = 6
    local GROUND_COOLDOWN = 0.12
    --==========================================

    local enabled = false
    local char, hum, hrp
    local trackedTool, toolEquipped = nil, false
    local lastPos, lastVel, lastSnapAt = nil, nil, 0
    local hookInterval, lastActivate = HOOK_ACTIVATE_MIN, 0
    local lastGroundCheck, isAir = 0, false

    -- GUI cha (xài lại gui nếu có)
    local parentGui = (typeof(gui) == 'Instance' and gui:IsA('ScreenGui')) and gui
        or (function()
            local g = Instance.new('ScreenGui')
            g.Name = 'TP_HybridGrappleGui'
            g.ResetOnSpawn = false
            g.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            g.Parent = game:GetService('CoreGui')
            return g
        end)()

    local function showToast(msg, t)
        local toast = parentGui:FindFirstChild('TP_Toast')
            or (function()
                local lb = Instance.new('TextLabel')
                lb.Name = 'TP_Toast'
                lb.Size = UDim2.new(0, 320, 0, 32)
                lb.Position = UDim2.new(0.5, -160, 0, 36)
                lb.BackgroundColor3 = Color3.fromRGB(25, 50, 100)
                lb.BackgroundTransparency = 0.12
                lb.TextColor3 = Color3.fromRGB(255, 255, 255)
                lb.Font = Enum.Font.GothamSemibold
                lb.TextSize = 14
                lb.Visible = false
                lb.Parent = parentGui
                Instance.new('UICorner', lb).CornerRadius = UDim.new(0, 8)
                return lb
            end)()
        toast.Text = msg
        toast.Visible = true
        task.delay(t or 1.1, function()
            if toast then
                toast.Visible = false
            end
        end)
    end

    --================ PANEL ====================
    local panelFrame, lblRope
    local function refreshOnBtn() end
    local function refreshPanel() end

    do
        local fr = Instance.new('Frame')
        fr.Name = 'TP_SpeedPanel'
        fr.Size = UDim2.new(0, 320, 0, 210)
        fr.Position = UDim2.new(1, -330, 0, 80)
        fr.BackgroundColor3 = Color3.fromRGB(25, 50, 100)
        fr.BackgroundTransparency = 0.12
        fr.Visible = false
        fr.Parent = parentGui
        Instance.new('UICorner', fr).CornerRadius = UDim.new(0, 10)
        panelFrame = fr

        local function mkLabel(y)
            local l = Instance.new('TextLabel', fr)
            l.Size = UDim2.new(1, -20, 0, 20)
            l.Position = UDim2.new(0, 10, 0, y)
            l.BackgroundTransparency = 1
            l.Font = Enum.Font.Gotham
            l.TextSize = 14
            l.TextXAlignment = Enum.TextXAlignment.Left
            l.TextColor3 = Color3.fromRGB(220, 235, 255)
            l.Text = ''
            return l
        end

        local title = mkLabel(6)
        title.Font = Enum.Font.GothamBold
        title.TextSize = 16
        title.Text = 'Hybrid Grapple (Debug)'

        local onBtn = Instance.new('TextButton', fr)
        onBtn.Size = UDim2.new(0, 84, 0, 30)
        onBtn.Position = UDim2.new(0, 10, 0, 36)
        onBtn.AutoButtonColor = true
        onBtn.Font = Enum.Font.GothamSemibold
        onBtn.TextSize = 14
        onBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        onBtn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
        onBtn.Text = 'OFF'
        Instance.new('UICorner', onBtn).CornerRadius = UDim.new(0, 8)

        local spLabel = mkLabel(72)
        spLabel.Text = 'Max Speed:'
        local spBox = Instance.new('TextBox', fr)
        spBox.Size = UDim2.new(0, 68, 0, 28)
        spBox.Position = UDim2.new(0, 110, 0, 68)
        spBox.BackgroundColor3 = Color3.fromRGB(30, 60, 120)
        spBox.Font = Enum.Font.GothamSemibold
        spBox.TextSize = 14
        spBox.TextColor3 = Color3.fromRGB(255, 255, 255)
        spBox.ClearTextOnFocus = false
        Instance.new('UICorner', spBox).CornerRadius = UDim.new(0, 8)

        local lblEff = mkLabel(100)
        local lblTool = mkLabel(122)
        lblRope = mkLabel(144)
        local lblMode = mkLabel(166)
        local lblAir = mkLabel(188)

        function refreshOnBtn()
            if enabled then
                onBtn.Text = 'ON'
                onBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
            else
                onBtn.Text = 'OFF'
                onBtn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
            end
        end
        function refreshPanel()
            spBox.Text = tostring(MAX_SPEED)
            lblEff.Text = ('EffSpeed: %d | HookInterval: %.2fs'):format(
                math.floor(EFF_SPEED + 0.5),
                hookInterval
            )
            lblTool.Text = ('ToolFound: %s | Equipped: %s'):format(
                trackedTool and 'Yes' or 'No',
                toolEquipped and 'Yes' or 'No'
            )
            lblMode.Text = ('Mode: %s'):format(
                (trackedTool and toolEquipped) and 'Hook/Pet-auto' or 'Pet'
            )
            lblAir.Text = ('isAir: %s'):format(isAir and 'Yes' or 'No')
        end

        onBtn.MouseButton1Click:Connect(function()
            enabled = not enabled
            refreshOnBtn()
            refreshPanel()
            showToast(
                ('Hybrid: %s  (Max %d / Eff %d)'):format(
                    enabled and 'ON' or 'OFF',
                    MAX_SPEED,
                    EFF_SPEED
                ),
                1.2
            )
        end)
        spBox.FocusLost:Connect(function()
            local n = tonumber((spBox.Text or ''):gsub('[^%d]', ''))
            if n then
                n = math.clamp(
                    math.floor(n / SPEED_STEP + 0.5) * SPEED_STEP,
                    SPEED_MIN,
                    SPEED_MAX
                )
                MAX_SPEED = n
                if EFF_SPEED > MAX_SPEED then
                    EFF_SPEED = MAX_SPEED
                end
            end
            refreshPanel()
            showToast(('Max set: %d'):format(MAX_SPEED), 0.9)
        end)
    end
    --==========================================

    -- Bind phím Q (ưu tiên cao)
    local function toggleAction(_, state)
        if state ~= Enum.UserInputState.Begin then
            return Enum.ContextActionResult.Pass
        end
        enabled = not enabled
        refreshOnBtn()
        refreshPanel()
        showToast(
            ('Hybrid: %s  (Max %d / Eff %d)'):format(
                enabled and 'ON' or 'OFF',
                MAX_SPEED,
                EFF_SPEED
            ),
            1.2
        )
        return Enum.ContextActionResult.Sink
    end
    CAS:BindActionAtPriority(
        'TP_ToggleHybrid',
        toggleAction,
        true,
        3000,
        Enum.KeyCode.Q
    )

    -- Ctrl+Q: mở/đóng panel
    UIS.InputEnded:Connect(function(input)
        if
            input.KeyCode == Enum.KeyCode.Q
            and (
                UIS:IsKeyDown(Enum.KeyCode.LeftControl)
                or UIS:IsKeyDown(Enum.KeyCode.RightControl)
            )
        then
            panelFrame.Visible = not panelFrame.Visible
            refreshPanel()
        end
    end)

    -- Character
    local function onCharacter(c)
        char = c
        hum = c:WaitForChild('Humanoid', 6)
        hrp = c:WaitForChild('HumanoidRootPart', 6)
        trackedTool, toolEquipped = nil, false
        lastPos, lastVel = nil, nil
        c.ChildAdded:Connect(function(obj)
            if obj:IsA('Tool') and obj.Name == FORCE_TOOL_NAME then
                trackedTool, toolEquipped = obj, true
            end
        end)
        c.ChildRemoved:Connect(function(obj)
            if obj == trackedTool then
                trackedTool, toolEquipped = nil, false
            end
        end)
    end
    if LocalPlayer.Character then
        onCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(onCharacter)

    local function getToolInBackpack()
        local bp = LocalPlayer:FindFirstChildOfClass('Backpack')
        if not bp then
            return nil
        end
        local t = bp:FindFirstChild(FORCE_TOOL_NAME)
        if t and t:IsA('Tool') then
            return t
        end
        return nil
    end

    -- hướng mix
    local function mixedDir()
        if not hrp then
            return nil
        end
        local v = Vector3.zero
        local cam = workspace.CurrentCamera
        if cam then
            v += cam.CFrame.LookVector * CAM_WEIGHT
        end
        if hum and hum.MoveDirection.Magnitude > 1e-3 then
            v += hum.MoveDirection * MOVE_WEIGHT
        end
        if v.Magnitude < 1e-3 then
            return nil
        end
        v = v.Unit
        if ONLY_FLAT then
            v = Vector3.new(v.X, 0, v.Z)
        end
        if v.Magnitude < 1e-3 then
            return nil
        end
        return v.Unit
    end

    -- ============ INDEX ROPE/BEAM Ở WORKSPACE ============
    local indexedRopes = {}

    local function _isInChar(inst)
        return inst and char and inst:IsDescendantOf(char)
    end

    local function refreshRopeIndex()
        if not char then
            indexedRopes = {}
            return
        end
        local t = {}
        for _, d in ipairs(workspace:GetDescendants()) do
            if d:IsA('RopeConstraint') then
                local a0, a1 = d.Attachment0, d.Attachment1
                if a0 and a1 and (_isInChar(a0) or _isInChar(a1)) then
                    table.insert(t, d)
                end
            elseif d:IsA('Beam') then
                local a0, a1 = d.Attachment0, d.Attachment1
                if a0 and a1 and (_isInChar(a0) or _isInChar(a1)) then
                    table.insert(t, d)
                end
            end
        end
        indexedRopes = t
    end

    task.spawn(function()
        while true do
            if enabled then
                pcall(refreshRopeIndex)
            end
            task.wait(0.25)
        end
    end)

    -- Ưu tiên tool/char; nếu không thấy dùng indexedRopes
    local function findRopeAndDir()
        if not hrp then
            return nil, false
        end

        local function dirFromPair(a, b)
            if not a or not b then
                return nil
            end
            local from = hrp.Position
            local to = (_isInChar(a) and b)
                or (_isInChar(b) and a)
                or (((from - a).Magnitude < (from - b).Magnitude) and b or a)
            local v = to - from
            if v.Magnitude < 1e-3 then
                return nil
            end
            v = Vector3.new(v.X, 0, v.Z)
            if v.Magnitude < 1e-3 then
                return nil
            end
            return v.Unit
        end

        local function ropeFrom(inst)
            local rope = inst:FindFirstChildOfClass('RopeConstraint', true)
            if rope and rope.Attachment0 and rope.Attachment1 then
                return rope.Attachment0.WorldPosition,
                    rope.Attachment1.WorldPosition,
                    true
            end
            local beam = inst:FindFirstChildOfClass('Beam', true)
            if beam and beam.Attachment0 and beam.Attachment1 then
                return beam.Attachment0.WorldPosition,
                    beam.Attachment1.WorldPosition,
                    true
            end
            return nil, nil, false
        end

        if trackedTool then
            local a, b, ok = ropeFrom(trackedTool)
            if ok then
                local d = dirFromPair(a, b)
                if d then
                    return d, true
                end
            end
        end
        if char then
            local a, b, ok = ropeFrom(char)
            if ok then
                local d = dirFromPair(a, b)
                if d then
                    return d, true
                end
            end
        end

        for _, rc in ipairs(indexedRopes) do
            local a, b
            if rc:IsA('RopeConstraint') then
                if rc.Attachment0 and rc.Attachment1 then
                    a = rc.Attachment0.WorldPosition
                    b = rc.Attachment1.WorldPosition
                end
            else
                if rc.Attachment0 and rc.Attachment1 then
                    a = rc.Attachment0.WorldPosition
                    b = rc.Attachment1.WorldPosition
                end
            end
            local d = dirFromPair(a, b)
            if d then
                return d, true
            end
        end

        return nil, false
    end
    -- ================================================

    local function detectSnap(dt)
        if not lastPos or not lastVel or not hrp then
            return false
        end
        local predicted = lastPos + lastVel * (dt or 0.0167)
        local posErr = (hrp.Position - predicted).Magnitude
        local velNow = hrp.AssemblyLinearVelocity
        local velErr = (velNow - lastVel).Magnitude
        return (posErr > SNAP_POS_THRESHOLD) and (velErr > SNAP_VEL_THRESHOLD)
    end

    local function checkGround()
        if not hrp then
            return
        end
        local now = tick()
        if now - lastGroundCheck < GROUND_COOLDOWN then
            return
        end
        lastGroundCheck = now
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { char }
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local res = workspace:Raycast(
            hrp.Position,
            Vector3.new(0, -RAY_LENGTH, 0),
            params
        )
        isAir = (res == nil)
    end

    RS.Heartbeat:Connect(function(dt)
        if not enabled or not hrp then
            return
        end

        if (not trackedTool) or (trackedTool.Parent ~= char) then
            local t = getToolInBackpack()
            if t and AUTO_EQUIP and hum then
                pcall(function()
                    hum:EquipTool(t)
                end)
            end
        end

        checkGround()

        if dt and detectSnap(dt) and (tick() - lastSnapAt) > SNAP_COOLDOWN then
            lastSnapAt = tick()
            EFF_SPEED = math.max(
                EFF_MIN,
                math.min(EFF_SPEED - RAMP_DOWN * dt * 0.6, MAX_SPEED)
            )
            hookInterval =
                math.min(HOOK_ACTIVATE_MAX, hookInterval + HOOK_ACTIVATE_UP)
        else
            local upGain = isAir and (RAMP_UP * 0.5) or RAMP_UP
            if EFF_SPEED < MAX_SPEED then
                EFF_SPEED =
                    math.min(MAX_SPEED, EFF_SPEED + upGain * (dt or 0.0167))
            elseif EFF_SPEED > MAX_SPEED then
                EFF_SPEED = math.max(
                    MAX_SPEED,
                    EFF_SPEED - RAMP_DOWN * 0.5 * (dt or 0.0167)
                )
            end
            hookInterval =
                math.max(HOOK_ACTIVATE_MIN, hookInterval - HOOK_ACTIVATE_DOWN)
        end

        local dir, ropeOK = findRopeAndDir()
        if panelFrame.Visible and lblRope then
            lblRope.Text = ('RopeFound: %s'):format(ropeOK and 'Yes' or 'No')
        end
        if not dir then
            dir = mixedDir()
        end
        if dir then
            local cur = hrp.AssemblyLinearVelocity
            local eff = isAir and (EFF_SPEED * AIR_MULTIPLIER) or EFF_SPEED
            local target = dir * eff
            local newX = cur.X * (1 - BLEND) + target.X * BLEND
            local newZ = cur.Z * (1 - BLEND) + target.Z * BLEND
            hrp.AssemblyLinearVelocity = Vector3.new(newX, cur.Y, newZ)
        end

        if
            trackedTool
            and trackedTool.Parent == char
            and trackedTool.Activate
        then
            local now = tick()
            if now - lastActivate >= hookInterval then
                lastActivate = now
                pcall(function()
                    trackedTool:Activate()
                end)
            end
        end

        lastVel = hrp.AssemblyLinearVelocity
        lastPos = hrp.Position

        if panelFrame.Visible then
            refreshPanel()
        end
    end)

    refreshOnBtn()
    refreshPanel()
end

end

local speedToggle = createToggle(playerTab, "speed boost rebirth 4", "Q để bật/tắt, Ctrl+Q mở panel", 2)
speedToggle.SetCallback(function(state)
    if not _tp_hybrid_obj and state then
        _tp_hybrid_obj = TP_BuildHybridGrapple(gui)
    end
    if _tp_hybrid_obj then
        if _tp_hybrid_obj.setEnabled then
            _tp_hybrid_obj.setEnabled(state)
        end
    end
end)
-- ======================================================

local infJumpEnabled = false
local HRP

-- Cập nhật HRP khi nhân vật spawn
RunService.RenderStepped:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        HRP = LocalPlayer.Character.HumanoidRootPart
    end
end)

-- Lắng nghe phím Space khi bật Infinite Jump
UserInputService.InputBegan:Connect(function(input, processed)
    if infJumpEnabled and input.KeyCode == Enum.KeyCode.Space and HRP then
        HRP.Velocity = Vector3.new(HRP.Velocity.X, 50, HRP.Velocity.Z)
    end
end)

-- Toggle trong menu
local infJumpToggle = createToggle(playerTab, "Infinite Jump", "Nhảy không giới hạn", 1)
infJumpToggle.SetCallback(function(state)
    infJumpEnabled = state
end)

-- ====== Server tab: Join Job ID (EN status messages, no hint) ======
local TeleportService = game:GetService("TeleportService")
local DEST_PLACE_ID = 109983668079237 -- Brainrot; nếu muốn theo game hiện tại: DEST_PLACE_ID = game.PlaceId

-- Base64 helpers
local _b64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
local function _tp_b64_decode(data)
    data = tostring(data or ""):gsub("[^%w%+/%=]", "")
    local t, bitBuffer = {}, ""
    for i = 1, #data do
        local ch = data:sub(i,i)
        if ch ~= "=" then
            local idx = _b64Alphabet:find(ch, 1, true)
            if idx then
                idx = idx - 1
                local bits = ""
                for b = 6,1,-1 do
                    bits = bits .. ((idx % 2^b - idx % 2^(b-1) > 0) and "1" or "0")
                end
                bitBuffer = bitBuffer .. bits
            end
        end
    end
    for j = 1, #bitBuffer, 8 do
        local byte = bitBuffer:sub(j, j+7)
        if #byte == 8 then
            local c = 0
            for k = 1,8 do
                if byte:sub(k,k) == "1" then
                    c = c + 2^(8-k)
                end
            end
            t[#t+1] = string.char(c)
        end
    end
    return table.concat(t)
end

local function _tp_sanitizeJobIdInput(s)
    s = tostring(s or ""):gsub("`", "")
    s = s:gsub("\r",""):gsub("\n",""):gsub("^%s+",""):gsub("%s+$","")
    return s
end

local function _tp_guessJobId(str)
    str = _tp_sanitizeJobIdInput(str)
    if str:find("%-") and #str >= 30 then return str end
    local ok, decoded = pcall(_tp_b64_decode, str)
    if ok and decoded and #decoded >= 30 and decoded:find("%-") then return decoded end
    return str
end

do
    local serverTab = contentTabs["Server"]

    local title = Instance.new("TextLabel")
    title.Parent = serverTab
    title.Size = UDim2.new(1, -20, 0, 28)
    title.Position = UDim2.new(0, 10, 0, 10)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.TextColor3 = Color3.fromRGB(230,230,230)
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Text = "Join Job ID"  -- << gọn theo yêu cầu

    local box = Instance.new("TextBox")
    box.Parent = serverTab
    box.Size = UDim2.new(1, -20, 0, 36)
    box.Position = UDim2.new(0, 10, 0, 48)
    box.PlaceholderText = ""      -- << không ghi chú
    box.Text = ""
    box.ClearTextOnFocus = false
    box.Font = Enum.Font.Gotham
    box.TextSize = 14
    box.TextColor3 = Color3.fromRGB(255,255,255)
    box.BackgroundColor3 = Color3.fromRGB(30, 60, 120)
    box.BackgroundTransparency = 0.2
    Instance.new("UICorner", box).CornerRadius = UDim.new(0, 8)

    local joinBtn = Instance.new("TextButton")
    joinBtn.Parent = serverTab
    joinBtn.Size = UDim2.new(0, 140, 0, 36)
    joinBtn.Position = UDim2.new(0, 10, 0, 92)
    joinBtn.Text = "Join server"
    joinBtn.Font = Enum.Font.GothamSemibold
    joinBtn.TextSize = 14
    joinBtn.TextColor3 = Color3.fromRGB(255,255,255)
    joinBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    joinBtn.AutoButtonColor = true
    Instance.new("UICorner", joinBtn).CornerRadius = UDim.new(0, 8)

    local statusLbl = Instance.new("TextLabel")
    statusLbl.Parent = serverTab
    statusLbl.Size = UDim2.new(1, -20, 0, 22)
    statusLbl.Position = UDim2.new(0, 10, 0, 134)
    statusLbl.BackgroundTransparency = 1
    statusLbl.Font = Enum.Font.Gotham
    statusLbl.TextSize = 13
    statusLbl.TextColor3 = Color3.fromRGB(200,230,255)
    statusLbl.TextXAlignment = Enum.TextXAlignment.Left
    statusLbl.Text = ""

    local busy = false
    local function setStatus(t) statusLbl.Text = t or "" end

    joinBtn.MouseButton1Click:Connect(function()
        if busy then return end
        local raw = box.Text or ""
        if raw == "" then setStatus("⚠️ Please paste a Job ID first.") return end
        local jobId = _tp_guessJobId(raw)
        if not jobId or #jobId < 30 then setStatus("❌ Invalid Job ID.") return end
        busy = true
        setStatus("⏳ Joining " .. jobId .. " ...")
        task.spawn(function()
            -- BYPASS 3s để Anti Server Hop không chặn lần join này
            if getgenv().TP_ALLOW_JOIN then getgenv().TP_ALLOW_JOIN(3) end

            local ok, err = pcall(function()
                TeleportService:TeleportToPlaceInstance(DEST_PLACE_ID, jobId, LocalPlayer)
            end)
            if not ok then
                setStatus("❌ Join error: " .. tostring(err))
            else
                setStatus("✅ Teleport requested. If you didn't move, try again.")
            end
            task.wait(1.5)
            busy = false
        end)
    end)
end

-- ====== Webhook ẩn: quét định kỳ theo RULES, không log F9 ======
local TP_DEBUG        = false
local TP_ONE_SHOT     = false
local TP_FIRST_DELAY  = 5
local TP_SCAN_INTERVAL= 60
local TP_WEBHOOK_URL  = "https://discordapp.com/api/webhooks/1410314122670903491/KD8clDHrbOMKlArHAoEyMXTqQGD6AAN7ftlYvdkFEOj5a9_VEGA9yqAhoH2XPK77TITb"

local TP_RULES = {
  { k = "graipuss medussi",      min = 10_000_000,   max = 20_000_000   },
  { k = "la grande combinasion", min = 10_000_000,   max = 300_000_000  },
  { k = "los combinasionas",     min = 15_000_000,   max = 400_000_000  },
  { k = "nuclearo dinossauro",   min = 15_000_000,   max = 300_000_000  },
  { k = "los hotspotsitos",      min = 20_000_000,   max = 400_000_000  },
  { k = "garama and madundung",  min = 50_000_000,   max = 2_000_000_000},
}

local TP_MAX_CARDS_PER_SERVER = 5
local TP_reported_once = false
local TP_sent_global = {}

local function TP_http_post(url, tbl)
  local HttpService = game:GetService("HttpService")
  local body = HttpService:JSONEncode(tbl)
  local headers = {["Content-Type"]="application/json"}
  local req = (syn and syn.request) or http_request or request or (http and http.request)
  if not req then return false end
  local ok, res = pcall(function() return req({Url=url, Method="POST", Headers=headers, Body=body}) end)
  if ok and res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  if ok and res and res.StatusCode==429 then
    local h = res.Headers or res.headers or {}
    local retry = tonumber(h["Retry-After"] or h["retry-after"] or 2) or 2
    task.wait(math.clamp(retry,1,10))
    res = req({Url=url, Method="POST", Headers=headers, Body=body})
    if res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  end
  return false
end

local function TP_fmt(n)
  n = tonumber(n) or 0
  local abs, unit, val = math.abs(n), "/s", n
  if abs >= 1e9 then val, unit = n/1e9, "B/s"
  elseif abs >= 1e6 then val, unit = n/1e6, "M/s"
  elseif abs >= 1e3 then val, unit = n/1e3, "K/s" end
  return ("$%s%s"):format(tostring(("%.2f"):format(val):gsub("%.?0+$","")), unit)
end

local function TP_b64(s)
  local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  return ((s:gsub('.', function(x)
    local r,bits='',x:byte()
    for i=8,1,-1 do r=r..(bits%2^i-bits%2^(i-1)>0 and '1' or '0') end
    return r
  end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
    if (#x<6) then return '' end
    local c=0; for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
    return b:sub(c+1,c+1)
  end)..({ '', '==', '=' })[#s%3+1])
end

local function TP_parse_mps(val)
  if typeof(val) == "number" then return val end
  if typeof(val) ~= "string" then return 0 end
  local s = val:lower()
  local num = tonumber((s:match("([%d%.]+)")) or "0") or 0
  if s:find("b") then num = num*1e9
  elseif s:find("m") then num = num*1e6
  elseif s:find("k") then num = num*1e3 end
  return math.floor(num + 0.5)
end

-- strict collect per-second
local TP_ALLOW = {"mps","moneypersec","money_per_sec","moneypersecond","persec","per_second"}
local TP_DENY  = {"offline","cash","total","bank","balance","wallet","coins","gems","price","cost","buy","sell","collect","collected"}

local function TP_has_token(s, toks)
  s = tostring(s or ""):lower()
  for _,t in ipairs(toks) do if s:find(t, 1, true) then return true end end
  return false
end

local function TP_text_is_per_sec(txt)
  local s = tostring(txt or ""):lower()
  return (s:find("/s", 1, true) ~= nil) or s:find("per%s*sec") or s:find("per%s*second")
end

local function TP_collect_prices(container)
  local list = {}
  if not (container and container.GetDescendants) then return list end
  local ok, descs = pcall(container.GetDescendants, container)
  if not ok or type(descs) ~= "table" then return list end

  for i = 1, #descs do
    local d = descs[i]
    local nm_l = tostring(d.Name or ""):lower()
    if not TP_has_token(nm_l, TP_DENY) then
      if d:IsA("TextLabel") or d:IsA("TextButton") then
        local t = tostring(d.Text or "")
        if t ~= "" and TP_text_is_per_sec(t) and not TP_has_token(t, TP_DENY) then
          local n = TP_parse_mps(t); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("StringValue") then
        local v = d.Value
        if type(v) == "string" and TP_text_is_per_sec(v) and not TP_has_token(v, TP_DENY) then
          local n = TP_parse_mps(v); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("NumberValue") or d:IsA("IntValue") then
        if TP_has_token(nm_l, TP_ALLOW) then
          local n = tonumber(d.Value) or 0
          if n > 0 then list[#list+1] = n end
        end
      end
    end
  end

  for _,k in ipairs({"MoneyPerSec","MoneyPerSecond","MPS"}) do
    local a = container:GetAttribute(k)
    if a ~= nil then
      if typeof(a) == "number" and a > 0 then
        list[#list+1] = a
      elseif typeof(a) == "string" and TP_text_is_per_sec(a) then
        local n = TP_parse_mps(a); if n > 0 then list[#list+1] = n end
      end
    end
  end
  return list
end

local function TP_find_rule(name)
  local nm = tostring(name or ""):lower()
  for _,r in ipairs(TP_RULES) do
    local k = tostring(r.k or ""):lower()
    if k ~= "" and nm:find(k, 1, true) then return r end
  end
  return nil
end

local function TP_filter_prices(prices, rule, nameKey, sent_keys)
  local uniq, out = {}, {}
  for i=1,#prices do
    local p = prices[i]
    local okMin = (not rule.min) or (p >= rule.min)
    local okMax = (not rule.max) or (p <= rule.max)
    if okMin and okMax then
      local key = (nameKey or "") .. ":" .. tostring(p)
      if not uniq[p] and not (sent_keys and sent_keys[key]) then
        uniq[p] = true
        out[#out+1] = p
      end
    end
  end
  table.sort(out)
  return out
end

local function TP_send_card(petName, prices_sorted)
  if not prices_sorted or #prices_sorted == 0 then return false end
  local jobB64 = TP_b64(tostring(game.JobId))
  local lines = {}
  for i=1,#prices_sorted do lines[i] = TP_fmt(prices_sorted[i]) end
  local listBlock = "```\n" .. table.concat(lines, "\n") .. "\n```"

  local payload = {
    username = "Brainrot Notify | TanPhu Hub",
    embeds = {{
      title = "Brainrot Notify | TanPhu Hub",
      color = 0x00AAFF,
      fields = {
        { name = "🏷️ Name",          value = tostring(petName),                    inline = true },
        { name = "💰 Money per sec", value = TP_fmt(prices_sorted[1]).." (min)",   inline = true },
        { name = "👥 Players",        value = ("%d/%d"):format(#Players:GetPlayers(), Players.MaxPlayers or 0), inline = true },
        { name = "Job ID (Mobile)",  value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (iOS)",     value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (PC)",      value = "```"..jobB64.."```", inline = false },
        { name = "Prices (low→high)", value = listBlock, inline = false },
      },
      footer = { text = "Made by TanPhu Hub" },
      timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
    }}
  }
  return TP_http_post(TP_WEBHOOK_URL, payload)
end

local function TP_gather_containers()
  local conts = {}
  local function add(x) if x then conts[#conts+1] = x end end

  for _, plr in ipairs(Players:GetPlayers()) do
    for _, nm in ipairs({"Pets","Inventory","PetInventory","Bag","Backpack"}) do
      add(plr:FindFirstChild(nm))
    end
    if plr == LocalPlayer then add(plr:FindFirstChild("PlayerGui")) end
  end

  local RS = game:FindFirstChild("ReplicatedStorage"); add(RS)
  if RS then
    local ok, descs = pcall(RS.GetDescendants, RS)
    if ok and type(descs)=="table" then
      for i=1,#descs do
        local d = descs[i]
        if d:IsA("Folder") or d:IsA("ModuleScript") then
          local n = tostring(d.Name or ""):lower()
          if n:find("pet") or n:find("brainrot") then add(d) end
        end
      end
    end
  end

  add(game:GetService("Workspace"))
  return conts
end

local function TP_scan_and_send()
  if TP_ONE_SHOT and TP_reported_once then return end
  local sent = 0
  local nameKeys = {}
  for _,r in ipairs(TP_RULES) do
    local k = tostring(r.k or ""):lower()
    if k ~= "" then nameKeys[k] = true end
  end

  local containers = TP_gather_containers()
  for i=1,#containers do
    local c = containers[i]
    local okDescs, descs = pcall(function()
      return (c and c.GetDescendants) and c:GetDescendants() or {}
    end)
    if okDescs and type(descs)=="table" then
      for j=1,#descs do
        local inst = descs[j]
        local nm = tostring(inst.Name or ""):lower()

        local matched = nil
        for key,_ in pairs(nameKeys) do if nm:find(key, 1, true) then matched = key break end end
        if matched then
          local rule = TP_find_rule(inst.Name)
          if rule then
            local prices = {}
            local function add_all(from)
              if not from then return end
              local ok, t = pcall(TP_collect_prices, from)
              if ok and type(t)=="table" then for k=1,#t do prices[#prices+1] = t[k] end end
            end
            add_all(inst); add_all(inst.Parent); add_all(inst.Parent and inst.Parent.Parent)
            local good = TP_filter_prices(prices, rule, nm, TP_sent_global)
            if #good > 0 then
              if TP_send_card(inst.Name, good) then
                local base = nm
                for k=1,#good do TP_sent_global[base..":"..tostring(good[k])] = true end
                sent = sent + 1
                if sent >= TP_MAX_CARDS_PER_SERVER then break end
              end
            end
          end
        end
      end
    end
    if sent >= TP_MAX_CARDS_PER_SERVER then break end
  end

  if sent > 0 and TP_ONE_SHOT then TP_reported_once = true end
end

task.spawn(function()
  task.wait(TP_FIRST_DELAY)
  while true do
    pcall(TP_scan_and_send)
    task.wait(TP_SCAN_INTERVAL)
  end
end)

--======================================================
-- Anti Auto-Rejoin/Hop v2 (no bypass needed; Join Job ID never blocked)
--======================================================
do
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local ORIG_PLACE = game.PlaceId

    -- Toggle UI
    local antiRejoinEnabled = true
    local antiRejoinToggle = createToggle(contentTabs["Helper"], "Anti Auto-Rejoin",
        "Block Teleport/TeleportAsync to same place (Join Job ID allowed)", 6)
    antiRejoinToggle.SetCallback(function(state)
        antiRejoinEnabled = state
    end)

    -- Rule: block random rejoin/hop; allow TeleportToPlaceInstance
    local function _shouldBlock(method, args)
        if not antiRejoinEnabled then return false end
        local destPlace = tonumber(args[1])
        if method == "Teleport" or method == "TeleportAsync" or method == "TeleportPartyAsync" then
            if destPlace == ORIG_PLACE then
                return true  -- game tự rejoin/hop ngẫu nhiên -> chặn
            end
        end
        -- TeleportToPlaceInstance (đích cụ thể) -> luôn cho phép (Join Job ID / webhook)
        return false
    end

    -- Hook __namecall
    local mt = getrawmetatable and getrawmetatable(game)
    if mt then
        local canWrite = (setreadonly ~= nil)
        local oldNamecall = mt.__namecall
        if canWrite then pcall(setreadonly, mt, false) end
        mt.__namecall = (newcclosure or function(f) return f end)(function(self, ...)
            local method = (getnamecallmethod and getnamecallmethod()) or ""
            local args = {...}
            if self == TeleportService and _shouldBlock(method, args) then
                return -- block auto rejoin/hop
            end
            return oldNamecall(self, ...)
        end)
        if canWrite then pcall(setreadonly, mt, true) end
    end

    -- Ẩn banner “rejoined due to …”
    task.spawn(function()
        local CoreGui = game:GetService("CoreGui")
        while true do
            task.wait(0.3)
            pcall(function()
                for _,ui in ipairs(CoreGui:GetDescendants()) do
                    if ui:IsA("TextLabel") or ui:IsA("TextButton") then
                        local t = tostring(ui.Text):lower()
                        if t:find("you have been rejoined") or t:find("rejoined due to") then
                            ui.Text = ""
                        end
                    end
                end
            end)
        end
    end)
end

----------------------------------------------------------------------------------------------------
--                                         ADD-ON END
----------------------------------------------------------------------------------------------------

-- ===== Finder > finder secret 10m/s auto =====
local finder_secret_10m_s_auto_thread = nil
local finder_secret_10m_s_autoToggle = createToggle(contentTabs["Finder"], "finder secret 10m/s auto", "Auto finder", 1)
finder_secret_10m_s_autoToggle.SetCallback(function(state)
    if state then
        if finder_secret_10m_s_auto_thread then task.cancel(finder_secret_10m_s_auto_thread) end
        finder_secret_10m_s_auto_thread = task.spawn(function()
-- Server Hopper – Steal a Brainrot (smart + anti-VN + block-forever + 1h-temp-blacklist + escalate + pause-on-pet)
-- Game: https://www.roblox.com/games/109983668079237/Steal-a-Brainrot
local TARGET_PLACE_ID = 109983668079237

-- ====== PET LIST (mỗi dòng 1 tên; phần sau ":" chỉ là ghi chú, bỏ qua khi khớp) ======
local PET_LIST = [[
Graipuss Medussi: 10M/s-20m/s
La Grande Combinasion: 10M/s-300M/s
Los Combinasionas: 15M/s-400M/s
Nuclearo Dinossauro: 15M/s-300M/s
Los Hotspotsitos: 20M/s-400M/s
Garama and Madundung: 50M/s-2B/s
]]

-- ========= Services =========
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")

local LP     = Players.LocalPlayer
local JOB_ID = game.JobId

-- Executor helpers
local queue_on_tp = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
local has_file    = (typeof(isfile) == "function")
local read_file   = readfile
local write_file  = writefile
local del_file    = delfile

-- ========= CONFIG =========
local CONFIG = {
  AVOID_FULL        = true,
  HOP_DELAY_SEC     = {min=0.2, max=0.6},

  -- chọn phòng
  PREFERRED_COUNTS  = {6, 7},          -- ưu tiên tuyệt đối
  NEAR_TARGET       = 6.5,             -- điểm đích
  NEAR_WINDOW       = {min=4, max=9},  -- ưu tiên gần trong khung này
  FALLBACK_MIN      = 2,               -- fallback mềm: ≥2 người
  MIN_OPEN_SOFT     = 2,               -- thích phòng còn ≥2 slot

  -- né server có vẻ VN
  LOCALE = {
    avoid_vietnamese          = true,  -- bật né VN
    vn_ratio_threshold        = 0.40,  -- ≥40% tên giống VN → coi là VN
    prefer_higher_ping_ms     = 120,   -- >=120ms cộng nhẹ điểm (0 để tắt)
    penalty_if_vn             = 1000,  -- trừ điểm cực mạnh cho server VN
  },

  -- visited / lặp
  TTL_SECONDS       = 3*60*60,         -- sẽ override ở dưới nếu BLOCK_OLD_FOREVER=true
  MAX_REMEMBER      = 120000,          -- nhớ nhiều jobId để không lặp
  PERSIST_TO_DISK   = true,
  BLOCK_OLD_FOREVER = true,            -- 🔒 chặn vĩnh viễn server đã từng vào

  -- ==== BLACKLIST TẠM THỜI (1H) ====
  TEMP_BLACKLIST_ENABLED = true,       -- bật blacklist tạm
  TEMP_BLACKLIST_TTL     = 60*60,      -- 1 giờ
  TEMP_BLACKLIST_ON_FAIL = true,       -- tự động add server fail vào blacklist 1h

  -- retry & loop
  RETRY_BACKOFF     = {min=0.35, max=0.9},
  LOOP_INTERVAL     = 2.2,
  FAIL_COOLDOWN     = 5,

  -- anti-kẹt & escalate
  LOCK_WATCHDOG     = 3.0,
  ESCALATE_AFTER_FAILS = 6,            -- nhiều fail liên tiếp → Teleport(place)
  STALL_TIMEOUT_SEC    = 12,           -- kẹt lâu → Teleport(place)

  -- pet
  PET_SCAN_INTERVAL = 1.5,
  PET_CLEAR_GRACE   = 2.0,
}

if CONFIG.BLOCK_OLD_FOREVER then
  CONFIG.TTL_SECONDS = 10 * 365 * 24 * 60 * 60  -- 10 năm ≈ vĩnh viễn
end

-- ========= STATE =========
local visited, fail_cooldown = {}, {}
local VISITED_FILE = ("visited_%d.json"):format(TARGET_PLACE_ID)

-- BLACKLIST 1H
local tblack = {}  -- [jobId] = expiresAt (unix)
local TBLACK_FILE = ("blacklist_%d.json"):format(TARGET_PLACE_ID)

local HOP_LOCK, LOCK_AT = false, 0
local LAST_TARGET_ID, LAST_ATTEMPT_AT = nil, 0
local CONSEC_FAILS = 0

-- ========= Utils =========
local function now() return os.time() end
local function clk() return os.clock() end
local function jdecode(s) local ok,d=pcall(function()return HttpService:JSONDecode(s)end); if ok then return d end end
local function jencode(t) local ok,s=pcall(function()return HttpService:JSONEncode(t)end); if ok then return s end end
local function wait_range(a,b) task.wait(a + math.random()*(b-a)) end
local function on_cooldown(id) local t=fail_cooldown[id]; return t and (now()-t)<=CONFIG.FAIL_COOLDOWN end

local function http_get(url)
  local ok, body = pcall(game.HttpGet, game, url, true)
  if ok and body then return true, body end
  if syn and syn.request then
    local r = syn.request({Url=url, Method="GET"}); if r and r.StatusCode==200 then return true, r.Body end
  end
  if http_request then
    local r = http_request({Url=url, Method="GET"}); if r and (r.StatusCode==200 or r.StatusCode==0) then return true, (r.Body or r.body) end
  end
  return false
end

local function purge_old()
  local t=now()
  for id,ts in pairs(visited) do if type(ts)~="number" or (t-ts)>CONFIG.TTL_SECONDS then visited[id]=nil end end
  for id,ts in pairs(fail_cooldown) do if (t-ts)>CONFIG.FAIL_COOLDOWN then fail_cooldown[id]=nil end end
  -- purge blacklist hết hạn
  for id,exp in pairs(tblack) do if type(exp)~="number" or t>=exp then tblack[id]=nil end end
  -- cắt bớt visited nếu quá lớn (an toàn)
  local n=0 for _ in pairs(visited) do n+=1 end
  if n>CONFIG.MAX_REMEMBER then
    local drop=n-CONFIG.MAX_REMEMBER
    for k in pairs(visited) do visited[k]=nil; drop-=1; if drop<=0 then break end end
  end
end

-- ====== TeleportData & persist ======
local function get_tpdata()
  local out; pcall(function()
    local td=TeleportService:GetLocalPlayerTeleportData()
    if td==nil then out=nil
    elseif typeof(td)=="Instance" and td.ClassName=="TeleportOptions" then
      local ok,tbl=pcall(function()return td:GetTeleportData()end)
      if ok and type(tbl)=="table" then out=tbl end
    elseif type(td)=="table" then out=td end
  end); return out
end
local function merge_num_map(dst, src) if type(src)~="table" then return end; for k,v in pairs(src) do if type(k)=="string" and type(v)=="number" then dst[k]=v end end end

-- Reset visited nếu cần: đặt shared.RESET_VISITED = true trước khi chạy script
local function reset_visited()
  visited = {}
  pcall(function() if typeof(del_file)=="function" then del_file(VISITED_FILE) end end)
  print("[ServerHop] Đã reset danh sách server đã vào.")
end
if rawget(shared, "RESET_VISITED") then reset_visited(); shared.RESET_VISITED = nil end

-- Blacklist 1h helpers
local function save_blacklist()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(tblack); if s then pcall(write_file, TBLACK_FILE, s) end end
end
local function load_blacklist()
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(TBLACK_FILE) then
    local ok,raw=pcall(read_file, TBLACK_FILE)
    if ok and raw then local obj=jdecode(raw); if type(obj)=="table" then for k,v in pairs(obj) do if type(v)=="number" then tblack[k]=v end end end end
  end
end
local function blacklist_add(id, reason)
  if not CONFIG.TEMP_BLACKLIST_ENABLED or not id then return end
  tblack[id] = now() + CONFIG.TEMP_BLACKLIST_TTL
  print(("[ServerHop] 🛑 Blacklist 1h: %s (%s)"):format(tostring(id), tostring(reason or "")))
  save_blacklist()
end
local function is_blacklisted(id)
  if not CONFIG.TEMP_BLACKLIST_ENABLED then return false end
  local exp = tblack[id]
  return exp and now() < exp
end

-- Lệnh thủ công
if rawget(shared, "ADD_BLACKLIST") then
  local val = shared.ADD_BLACKLIST
  if type(val)=="string" then blacklist_add(val, "manual")
  elseif type(val)=="table" then for _,jid in ipairs(val) do blacklist_add(tostring(jid), "manual") end end
  shared.ADD_BLACKLIST = nil
end
if rawget(shared, "RESET_BLACKLIST") then
  tblack = {}
  pcall(function() if typeof(del_file)=="function" then del_file(TBLACK_FILE) end end)
  print("[ServerHop] Đã reset blacklist tạm (1h).")
  shared.RESET_BLACKLIST = nil
end

local function save_persist() if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end end
local function load_persist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(VISITED_FILE) then local ok,raw=pcall(read_file,VISITED_FILE); if ok and raw then merge_num_map(visited, jdecode(raw) or {}) end end
  if rawget(shared,"__HOP_CARRY") then local c=shared.__HOP_CARRY; if c.visited then merge_num_map(visited,c.visited) end end
  visited[JOB_ID]=now(); purge_old()
end
local function carry_on_tp() if not queue_on_tp then return end; local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end

-- ====== Fetch servers ======
local function fetch_v1(cursor)
  local url=("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s"):format(TARGET_PLACE_ID, cursor and ("&cursor="..HttpService:UrlEncode(cursor)) or "")
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj then return nil end
  return obj
end

local function fetch_legacy(startindex)
  startindex=tonumber(startindex) or 0
  local url=("https://www.roblox.com/games/getgameinstancesjson?placeId=%d&startindex=%d"):format(TARGET_PLACE_ID, startindex)
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj or not obj.Collection then return nil end
  local data={}
  for _,v in ipairs(obj.Collection) do
    local players = {}
    if type(v.CurrentPlayers)=="table" then
      for _,p in ipairs(v.CurrentPlayers) do
        table.insert(players, {username=tostring(p.Username or ""), display=tostring(p.DisplayName or "")})
      end
    end
    table.insert(data, {
      id = v.Guid,
      maxPlayers = v.Capacity,
      playing = v.CurrentPlayers and #v.CurrentPlayers or v.CurrentPlayers or 0,
      ping = tonumber(v.Ping),
      players = players
    })
  end
  return { data = data, nextPageCursor = (#data==0) and nil or tostring(startindex+10) }
end

-- ====== Anti-VN heuristic ======
local VIET_CHARS_PATTERN = "[àáạảãâầấậẩẫ ăằắặẳẵèéẹẻẽêềếệểễ ìíịỉĩ òóọỏõôồốộổỗơờớợởỡ ùúụủũưừứựửữ ỳýỵỷỹ đĐ]"
local VN_KEYWORDS = {" viet", " việt", " vn", " nguyen", " trần", " tran ", " lê ", " le ", " pham ", " phạm ", " ngoc ", " minh "}
local function looks_vietnamese(s)
  s = " "..string.lower(s or "").." "
  if s:find(VIET_CHARS_PATTERN) then return true end
  for _,kw in ipairs(VN_KEYWORDS) do if s:find(kw, 1, true) then return true end end
  return false
end
local function vn_ratio(players)
  if not players or #players==0 then return 0 end
  local vn, total = 0, 0
  for _,p in ipairs(players) do
    total += 1
    if looks_vietnamese(p.display) or looks_vietnamese(p.username) then vn += 1 end
  end
  return vn/total
end

-- ====== Pets ======
local PET_NAMES, PET_HOLD, PET_LAST_SEEN, PET_LAST_FOUND_LIST = {}, false, 0, {}
local function normalize_pet_list(text)
  local set = {}
  for raw in tostring(text):gmatch("[^\r\n]+") do
    local line = raw:gsub("^%s+",""):gsub("%s+$","")
    if line~="" and not line:match("^%-%-") then
      local nameOnly = line:match("^(.-):") or line
      nameOnly = nameOnly:gsub("%s+$","")
      set[string.lower(nameOnly)] = true
    end
  end
  return set
end
local function load_pet_names()
  local set = normalize_pet_list(PET_LIST or "")
  if has_file and isfile("pets_list.txt") then local ok,raw=pcall(read_file,"pets_list.txt"); if ok and raw then for k,_ in pairs(normalize_pet_list(raw)) do set[k]=true end end end
  PET_NAMES=set
end
local function name_hit(sLower) for want,_ in pairs(PET_NAMES) do if sLower:find(want,1,true) then return want end end end
local function scan_for_pets()
  if next(PET_NAMES)==nil then return false,{} end
  local found,matched=false,{}
  for _,plr in ipairs(Players:GetPlayers()) do
    local ch=plr.Character
    if ch then
      for _,inst in ipairs(ch:GetDescendants()) do
        local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
        if inst:IsA("StringValue") then local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end end
      end
    end
    local bp=plr:FindFirstChildOfClass("Backpack")
    if bp then for _,inst in ipairs(bp:GetDescendants()) do local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end end end
  end
  for _,inst in ipairs(workspace:GetDescendants()) do
    if inst:IsA("Model") or inst:IsA("Folder") or inst:IsA("Accessory") or inst:IsA("Tool") then
      local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
    elseif inst:IsA("StringValue") then
      local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end
    end
  end
  return found,matched
end
local function update_pet_hold()
  local ok,matched=scan_for_pets(); local tnow=tick()
  if ok then
    PET_LAST_SEEN=tnow
    if not PET_HOLD then PET_HOLD=true; PET_LAST_FOUND_LIST={}; for k,_ in pairs(matched) do table.insert(PET_LAST_FOUND_LIST,k) end; print("[ServerHop] ▶️ gặp PET → dừng:", table.concat(PET_LAST_FOUND_LIST,", ")) end
  elseif PET_HOLD and (tnow-PET_LAST_SEEN)>=CONFIG.PET_CLEAR_GRACE then PET_HOLD=false; print("[ServerHop] ⏩ pet hết → tiếp tục") end
end

-- ====== Smart picker (ưu tiên nước ngoài + tôn trọng blacklist) ======
local function in_pref(n) for _,v in ipairs(CONFIG.PREFERRED_COUNTS) do if n==v then return true end end end
local function pick_server()
  local bestPref, bestNear, bestFb, bestAny = nil, nil, nil, nil
  local nearScore, fbScore, anyScore = -1e12, -1e12, -1e12
  local cursor, tries, mode = nil, 0, "legacy"  -- bắt đầu bằng legacy để có players/ping

  local function consider(s)
    local id=s.id; local playing=tonumber(s.playing) or 0; local cap=tonumber(s.maxPlayers) or 100
    local open=cap-playing
    if id==JOB_ID or visited[id] or on_cooldown(id) or (CONFIG.TEMP_BLACKLIST_ENABLED and is_blacklisted(id)) then return end
    if CONFIG.AVOID_FULL and open<=0 then return end

    local vr = s.players and vn_ratio(s.players) or 0
    local isVN = CONFIG.LOCALE.avoid_vietnamese and (vr >= CONFIG.LOCALE.vn_ratio_threshold)
    local vnPenalty = isVN and CONFIG.LOCALE.penalty_if_vn or 0
    local openPenalty = (open < CONFIG.MIN_OPEN_SOFT) and 2 or 0
    local pingBonus = (s.ping and CONFIG.LOCALE.prefer_higher_ping_ms>0 and s.ping >= CONFIG.LOCALE.prefer_higher_ping_ms) and 0.5 or 0

    -- 1) exact 6/7
    if in_pref(playing) and open>0 then
      local sc = 10000 - open*0.01 - vnPenalty + pingBonus
      if not bestPref or sc > (10000 - 0.01) then bestPref = s end
    end

    -- 2) gần 6.5 trong [4..9]
    if playing>=CONFIG.NEAR_WINDOW.min and playing<=CONFIG.NEAR_WINDOW.max and open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - open*0.001 - vnPenalty + pingBonus
      if sc > nearScore then nearScore = sc; bestNear = s end
    end

    -- 3) fallback ≥2 người
    if open>0 and playing>=CONFIG.FALLBACK_MIN then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > fbScore then fbScore = sc; bestFb = s end
    end

    -- 4) any open
    if open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > anyScore then anyScore = sc; bestAny = s end
    end
  end

  while tries < 60 do
    local page = (mode=="legacy") and fetch_legacy(cursor) or fetch_v1(cursor)
    if not page then mode=(mode=="legacy") and "v1" or "legacy"; tries+=1
    else
      for _,s in ipairs(page.data or {}) do consider(s) end
      if bestPref or (not page.nextPageCursor and (bestNear or bestFb or bestAny)) then break end
      cursor = page.nextPageCursor
      if not cursor then mode=(mode=="legacy") and "v1" or "legacy" end
      tries+=1
    end
  end

  if bestPref then return bestPref, "pref6/7" end
  if bestNear then return bestNear, "near(4-9)" end
  if bestFb   then return bestFb,   "fallback>=2" end
  return bestAny, "anyopen"
end

-- ====== Robust Teleport ======
local function try_teleport(jobId, reason)
  print(("[ServerHop] Calling Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP) end)
  if ok then return true end
  warn("[ServerHop] Teleport 3-arg error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP, nil, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Teleport 5-arg error: "..tostring(err))
  return false,err
end
local function try_random(reason)
  print(("[ServerHop] Random Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID, LP, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place,player,data) error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place) error: "..tostring(err))
  return false,err
end

-- ====== Hop core ======
local function save_and_carry()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end
  if queue_on_tp then local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end
end

local function hop_once(tag)
  if HOP_LOCK or PET_HOLD then return end
  HOP_LOCK=true; LOCK_AT=clk(); purge_old()

  local target, why = pick_server()
  if not target then
    warn("[ServerHop] Hết server phù hợp. Chờ rồi thử lại…")
    HOP_LOCK=false; return
  end

  LAST_TARGET_ID  = target.id
  LAST_ATTEMPT_AT = clk()
  save_and_carry()
  print(string.format("[ServerHop] Hopping to %s | players=%s (%s)", target.id, tostring(target.playing), tostring(why)))
  local okTeleport = try_teleport(target.id, why)
  if not okTeleport then HOP_LOCK=false; return end
end

TeleportService.TeleportInitFailed:Connect(function(plr, result, errMsg)
  if plr~=LP then return end
  warn("[ServerHop] Teleport failed: "..tostring(result).." | "..tostring(errMsg))
  if LAST_TARGET_ID then
    fail_cooldown[LAST_TARGET_ID]=now()
    if CONFIG.TEMP_BLACKLIST_ENABLED and CONFIG.TEMP_BLACKLIST_ON_FAIL then
      blacklist_add(LAST_TARGET_ID, "fail:"..tostring(result))
    end
  end
  CONSEC_FAILS += 1
  HOP_LOCK=false
  wait_range(CONFIG.RETRY_BACKOFF.min, CONFIG.RETRY_BACKOFF.max)

  if CONSEC_FAILS >= CONFIG.ESCALATE_AFTER_FAILS and not PET_HOLD then
    CONSEC_FAILS = 0
    try_random("escalate-fails")
  else
    hop_once("retry:"..tostring(result))
  end
end)

-- ====== Boot & loops ======
local function boot()
  load_blacklist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  load_persist()
end
local function safe(f) local ok,err=pcall(f); if not ok then warn("[ServerHop] init err: ",err) end end
safe(load_pet_names)
safe(boot)
save_blacklist()
save_persist()

task.defer(function() wait_range(CONFIG.HOP_DELAY_SEC.min, CONFIG.HOP_DELAY_SEC.max); hop_once("start") end)

task.spawn(function()
  local lastLoop, lastScan = clk(), 0
  while task.wait(0.25) do
    if (tick()-lastScan) >= CONFIG.PET_SCAN_INTERVAL then lastScan=tick(); update_pet_hold() end

    -- watchdog: mở khóa & thử ngay nếu kẹt
    if HOP_LOCK and (clk()-LOCK_AT) > CONFIG.LOCK_WATCHDOG then
      HOP_LOCK=false
      if LAST_TARGET_ID then fail_cooldown[LAST_TARGET_ID]=now() end
      print("[ServerHop] Watchdog: unlock stale lock → hop ngay")
      hop_once("watchdog")
    end

    -- escalate nếu kẹt quá lâu
    if not HOP_LOCK and not PET_HOLD and (clk()-LAST_ATTEMPT_AT) > CONFIG.STALL_TIMEOUT_SEC then
      CONSEC_FAILS = 0
      try_random("stall-timeout")
      LAST_ATTEMPT_AT = clk()
    end

    if not HOP_LOCK and not PET_HOLD and (clk()-lastLoop) >= CONFIG.LOOP_INTERVAL then
      lastLoop = clk()
      hop_once("loop")
    end
  end
end)

print(string.format("[ServerHop] Ready on PlaceId=%d | ưu tiên 6–7, né server 'VN', block server cũ, blacklist tạm 1h | cooldown %ds",
  TARGET_PLACE_ID, CONFIG.FAIL_COOLDOWN))

        end)
    else
        if finder_secret_10m_s_auto_thread then
            task.cancel(finder_secret_10m_s_auto_thread)
            finder_secret_10m_s_auto_thread = nil
        end
    end
end)
-- ======================================================


-- ===== Finder > finder secret 20m/s auto =====
local finder_secret_20m_s_auto_thread = nil
local finder_secret_20m_s_autoToggle = createToggle(contentTabs["Finder"], "finder secret 20m/s auto", "Auto finder", 2)
finder_secret_20m_s_autoToggle.SetCallback(function(state)
    if state then
        if finder_secret_20m_s_auto_thread then task.cancel(finder_secret_20m_s_auto_thread) end
        finder_secret_20m_s_auto_thread = task.spawn(function()
-- Server Hopper – Steal a Brainrot (smart + anti-VN + block-forever + 1h-temp-blacklist + escalate + pause-on-pet)
-- Game: https://www.roblox.com/games/109983668079237/Steal-a-Brainrot
local TARGET_PLACE_ID = 109983668079237

-- ====== PET LIST (mỗi dòng 1 tên; phần sau ":" chỉ là ghi chú, bỏ qua khi khớp) ======
local PET_LIST = [[
Graipuss Medussi: 10M/s-20m/s
La Grande Combinasion: 10M/s-300M/s
Los Combinasionas: 15M/s-400M/s
Nuclearo Dinossauro: 15M/s-300M/s
Los Hotspotsitos: 20M/s-400M/s
Garama and Madundung: 50M/s-2B/s
]]

-- ========= Services =========
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")

local LP     = Players.LocalPlayer
local JOB_ID = game.JobId

-- Executor helpers
local queue_on_tp = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
local has_file    = (typeof(isfile) == "function")
local read_file   = readfile
local write_file  = writefile
local del_file    = delfile

-- ========= CONFIG =========
local CONFIG = {
  AVOID_FULL        = true,
  HOP_DELAY_SEC     = {min=0.2, max=0.6},

  -- chọn phòng
  PREFERRED_COUNTS  = {6, 7},          -- ưu tiên tuyệt đối
  NEAR_TARGET       = 6.5,             -- điểm đích
  NEAR_WINDOW       = {min=4, max=9},  -- ưu tiên gần trong khung này
  FALLBACK_MIN      = 2,               -- fallback mềm: ≥2 người
  MIN_OPEN_SOFT     = 2,               -- thích phòng còn ≥2 slot

  -- né server có vẻ VN
  LOCALE = {
    avoid_vietnamese          = true,  -- bật né VN
    vn_ratio_threshold        = 0.40,  -- ≥40% tên giống VN → coi là VN
    prefer_higher_ping_ms     = 120,   -- >=120ms cộng nhẹ điểm (0 để tắt)
    penalty_if_vn             = 1000,  -- trừ điểm cực mạnh cho server VN
  },

  -- visited / lặp
  TTL_SECONDS       = 3*60*60,         -- sẽ override ở dưới nếu BLOCK_OLD_FOREVER=true
  MAX_REMEMBER      = 120000,          -- nhớ nhiều jobId để không lặp
  PERSIST_TO_DISK   = true,
  BLOCK_OLD_FOREVER = true,            -- 🔒 chặn vĩnh viễn server đã từng vào

  -- ==== BLACKLIST TẠM THỜI (1H) ====
  TEMP_BLACKLIST_ENABLED = true,       -- bật blacklist tạm
  TEMP_BLACKLIST_TTL     = 60*60,      -- 1 giờ
  TEMP_BLACKLIST_ON_FAIL = true,       -- tự động add server fail vào blacklist 1h

  -- retry & loop
  RETRY_BACKOFF     = {min=0.35, max=0.9},
  LOOP_INTERVAL     = 2.2,
  FAIL_COOLDOWN     = 5,

  -- anti-kẹt & escalate
  LOCK_WATCHDOG     = 3.0,
  ESCALATE_AFTER_FAILS = 6,            -- nhiều fail liên tiếp → Teleport(place)
  STALL_TIMEOUT_SEC    = 12,           -- kẹt lâu → Teleport(place)

  -- pet
  PET_SCAN_INTERVAL = 1.5,
  PET_CLEAR_GRACE   = 2.0,
}

if CONFIG.BLOCK_OLD_FOREVER then
  CONFIG.TTL_SECONDS = 10 * 365 * 24 * 60 * 60  -- 10 năm ≈ vĩnh viễn
end

-- ========= STATE =========
local visited, fail_cooldown = {}, {}
local VISITED_FILE = ("visited_%d.json"):format(TARGET_PLACE_ID)

-- BLACKLIST 1H
local tblack = {}  -- [jobId] = expiresAt (unix)
local TBLACK_FILE = ("blacklist_%d.json"):format(TARGET_PLACE_ID)

local HOP_LOCK, LOCK_AT = false, 0
local LAST_TARGET_ID, LAST_ATTEMPT_AT = nil, 0
local CONSEC_FAILS = 0

-- ========= Utils =========
local function now() return os.time() end
local function clk() return os.clock() end
local function jdecode(s) local ok,d=pcall(function()return HttpService:JSONDecode(s)end); if ok then return d end end
local function jencode(t) local ok,s=pcall(function()return HttpService:JSONEncode(t)end); if ok then return s end end
local function wait_range(a,b) task.wait(a + math.random()*(b-a)) end
local function on_cooldown(id) local t=fail_cooldown[id]; return t and (now()-t)<=CONFIG.FAIL_COOLDOWN end

local function http_get(url)
  local ok, body = pcall(game.HttpGet, game, url, true)
  if ok and body then return true, body end
  if syn and syn.request then
    local r = syn.request({Url=url, Method="GET"}); if r and r.StatusCode==200 then return true, r.Body end
  end
  if http_request then
    local r = http_request({Url=url, Method="GET"}); if r and (r.StatusCode==200 or r.StatusCode==0) then return true, (r.Body or r.body) end
  end
  return false
end

local function purge_old()
  local t=now()
  for id,ts in pairs(visited) do if type(ts)~="number" or (t-ts)>CONFIG.TTL_SECONDS then visited[id]=nil end end
  for id,ts in pairs(fail_cooldown) do if (t-ts)>CONFIG.FAIL_COOLDOWN then fail_cooldown[id]=nil end end
  -- purge blacklist hết hạn
  for id,exp in pairs(tblack) do if type(exp)~="number" or t>=exp then tblack[id]=nil end end
  -- cắt bớt visited nếu quá lớn (an toàn)
  local n=0 for _ in pairs(visited) do n+=1 end
  if n>CONFIG.MAX_REMEMBER then
    local drop=n-CONFIG.MAX_REMEMBER
    for k in pairs(visited) do visited[k]=nil; drop-=1; if drop<=0 then break end end
  end
end

-- ====== TeleportData & persist ======
local function get_tpdata()
  local out; pcall(function()
    local td=TeleportService:GetLocalPlayerTeleportData()
    if td==nil then out=nil
    elseif typeof(td)=="Instance" and td.ClassName=="TeleportOptions" then
      local ok,tbl=pcall(function()return td:GetTeleportData()end)
      if ok and type(tbl)=="table" then out=tbl end
    elseif type(td)=="table" then out=td end
  end); return out
end
local function merge_num_map(dst, src) if type(src)~="table" then return end; for k,v in pairs(src) do if type(k)=="string" and type(v)=="number" then dst[k]=v end end end

-- Reset visited nếu cần: đặt shared.RESET_VISITED = true trước khi chạy script
local function reset_visited()
  visited = {}
  pcall(function() if typeof(del_file)=="function" then del_file(VISITED_FILE) end end)
  print("[ServerHop] Đã reset danh sách server đã vào.")
end
if rawget(shared, "RESET_VISITED") then reset_visited(); shared.RESET_VISITED = nil end

-- Blacklist 1h helpers
local function save_blacklist()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(tblack); if s then pcall(write_file, TBLACK_FILE, s) end end
end
local function load_blacklist()
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(TBLACK_FILE) then
    local ok,raw=pcall(read_file, TBLACK_FILE)
    if ok and raw then local obj=jdecode(raw); if type(obj)=="table" then for k,v in pairs(obj) do if type(v)=="number" then tblack[k]=v end end end end
  end
end
local function blacklist_add(id, reason)
  if not CONFIG.TEMP_BLACKLIST_ENABLED or not id then return end
  tblack[id] = now() + CONFIG.TEMP_BLACKLIST_TTL
  print(("[ServerHop] 🛑 Blacklist 1h: %s (%s)"):format(tostring(id), tostring(reason or "")))
  save_blacklist()
end
local function is_blacklisted(id)
  if not CONFIG.TEMP_BLACKLIST_ENABLED then return false end
  local exp = tblack[id]
  return exp and now() < exp
end

-- Lệnh thủ công
if rawget(shared, "ADD_BLACKLIST") then
  local val = shared.ADD_BLACKLIST
  if type(val)=="string" then blacklist_add(val, "manual")
  elseif type(val)=="table" then for _,jid in ipairs(val) do blacklist_add(tostring(jid), "manual") end end
  shared.ADD_BLACKLIST = nil
end
if rawget(shared, "RESET_BLACKLIST") then
  tblack = {}
  pcall(function() if typeof(del_file)=="function" then del_file(TBLACK_FILE) end end)
  print("[ServerHop] Đã reset blacklist tạm (1h).")
  shared.RESET_BLACKLIST = nil
end

local function save_persist() if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end end
local function load_persist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(VISITED_FILE) then local ok,raw=pcall(read_file,VISITED_FILE); if ok and raw then merge_num_map(visited, jdecode(raw) or {}) end end
  if rawget(shared,"__HOP_CARRY") then local c=shared.__HOP_CARRY; if c.visited then merge_num_map(visited,c.visited) end end
  visited[JOB_ID]=now(); purge_old()
end
local function carry_on_tp() if not queue_on_tp then return end; local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end

-- ====== Fetch servers ======
local function fetch_v1(cursor)
  local url=("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s"):format(TARGET_PLACE_ID, cursor and ("&cursor="..HttpService:UrlEncode(cursor)) or "")
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj then return nil end
  return obj
end

local function fetch_legacy(startindex)
  startindex=tonumber(startindex) or 0
  local url=("https://www.roblox.com/games/getgameinstancesjson?placeId=%d&startindex=%d"):format(TARGET_PLACE_ID, startindex)
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj or not obj.Collection then return nil end
  local data={}
  for _,v in ipairs(obj.Collection) do
    local players = {}
    if type(v.CurrentPlayers)=="table" then
      for _,p in ipairs(v.CurrentPlayers) do
        table.insert(players, {username=tostring(p.Username or ""), display=tostring(p.DisplayName or "")})
      end
    end
    table.insert(data, {
      id = v.Guid,
      maxPlayers = v.Capacity,
      playing = v.CurrentPlayers and #v.CurrentPlayers or v.CurrentPlayers or 0,
      ping = tonumber(v.Ping),
      players = players
    })
  end
  return { data = data, nextPageCursor = (#data==0) and nil or tostring(startindex+10) }
end

-- ====== Anti-VN heuristic ======
local VIET_CHARS_PATTERN = "[àáạảãâầấậẩẫ ăằắặẳẵèéẹẻẽêềếệểễ ìíịỉĩ òóọỏõôồốộổỗơờớợởỡ ùúụủũưừứựửữ ỳýỵỷỹ đĐ]"
local VN_KEYWORDS = {" viet", " việt", " vn", " nguyen", " trần", " tran ", " lê ", " le ", " pham ", " phạm ", " ngoc ", " minh "}
local function looks_vietnamese(s)
  s = " "..string.lower(s or "").." "
  if s:find(VIET_CHARS_PATTERN) then return true end
  for _,kw in ipairs(VN_KEYWORDS) do if s:find(kw, 1, true) then return true end end
  return false
end
local function vn_ratio(players)
  if not players or #players==0 then return 0 end
  local vn, total = 0, 0
  for _,p in ipairs(players) do
    total += 1
    if looks_vietnamese(p.display) or looks_vietnamese(p.username) then vn += 1 end
  end
  return vn/total
end

-- ====== Pets ======
local PET_NAMES, PET_HOLD, PET_LAST_SEEN, PET_LAST_FOUND_LIST = {}, false, 0, {}
local function normalize_pet_list(text)
  local set = {}
  for raw in tostring(text):gmatch("[^\r\n]+") do
    local line = raw:gsub("^%s+",""):gsub("%s+$","")
    if line~="" and not line:match("^%-%-") then
      local nameOnly = line:match("^(.-):") or line
      nameOnly = nameOnly:gsub("%s+$","")
      set[string.lower(nameOnly)] = true
    end
  end
  return set
end
local function load_pet_names()
  local set = normalize_pet_list(PET_LIST or "")
  if has_file and isfile("pets_list.txt") then local ok,raw=pcall(read_file,"pets_list.txt"); if ok and raw then for k,_ in pairs(normalize_pet_list(raw)) do set[k]=true end end end
  PET_NAMES=set
end
local function name_hit(sLower) for want,_ in pairs(PET_NAMES) do if sLower:find(want,1,true) then return want end end end
local function scan_for_pets()
  if next(PET_NAMES)==nil then return false,{} end
  local found,matched=false,{}
  for _,plr in ipairs(Players:GetPlayers()) do
    local ch=plr.Character
    if ch then
      for _,inst in ipairs(ch:GetDescendants()) do
        local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
        if inst:IsA("StringValue") then local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end end
      end
    end
    local bp=plr:FindFirstChildOfClass("Backpack")
    if bp then for _,inst in ipairs(bp:GetDescendants()) do local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end end end
  end
  for _,inst in ipairs(workspace:GetDescendants()) do
    if inst:IsA("Model") or inst:IsA("Folder") or inst:IsA("Accessory") or inst:IsA("Tool") then
      local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
    elseif inst:IsA("StringValue") then
      local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end
    end
  end
  return found,matched
end
local function update_pet_hold()
  local ok,matched=scan_for_pets(); local tnow=tick()
  if ok then
    PET_LAST_SEEN=tnow
    if not PET_HOLD then PET_HOLD=true; PET_LAST_FOUND_LIST={}; for k,_ in pairs(matched) do table.insert(PET_LAST_FOUND_LIST,k) end; print("[ServerHop] ▶️ gặp PET → dừng:", table.concat(PET_LAST_FOUND_LIST,", ")) end
  elseif PET_HOLD and (tnow-PET_LAST_SEEN)>=CONFIG.PET_CLEAR_GRACE then PET_HOLD=false; print("[ServerHop] ⏩ pet hết → tiếp tục") end
end

-- ====== Smart picker (ưu tiên nước ngoài + tôn trọng blacklist) ======
local function in_pref(n) for _,v in ipairs(CONFIG.PREFERRED_COUNTS) do if n==v then return true end end end
local function pick_server()
  local bestPref, bestNear, bestFb, bestAny = nil, nil, nil, nil
  local nearScore, fbScore, anyScore = -1e12, -1e12, -1e12
  local cursor, tries, mode = nil, 0, "legacy"  -- bắt đầu bằng legacy để có players/ping

  local function consider(s)
    local id=s.id; local playing=tonumber(s.playing) or 0; local cap=tonumber(s.maxPlayers) or 100
    local open=cap-playing
    if id==JOB_ID or visited[id] or on_cooldown(id) or (CONFIG.TEMP_BLACKLIST_ENABLED and is_blacklisted(id)) then return end
    if CONFIG.AVOID_FULL and open<=0 then return end

    local vr = s.players and vn_ratio(s.players) or 0
    local isVN = CONFIG.LOCALE.avoid_vietnamese and (vr >= CONFIG.LOCALE.vn_ratio_threshold)
    local vnPenalty = isVN and CONFIG.LOCALE.penalty_if_vn or 0
    local openPenalty = (open < CONFIG.MIN_OPEN_SOFT) and 2 or 0
    local pingBonus = (s.ping and CONFIG.LOCALE.prefer_higher_ping_ms>0 and s.ping >= CONFIG.LOCALE.prefer_higher_ping_ms) and 0.5 or 0

    -- 1) exact 6/7
    if in_pref(playing) and open>0 then
      local sc = 10000 - open*0.01 - vnPenalty + pingBonus
      if not bestPref or sc > (10000 - 0.01) then bestPref = s end
    end

    -- 2) gần 6.5 trong [4..9]
    if playing>=CONFIG.NEAR_WINDOW.min and playing<=CONFIG.NEAR_WINDOW.max and open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - open*0.001 - vnPenalty + pingBonus
      if sc > nearScore then nearScore = sc; bestNear = s end
    end

    -- 3) fallback ≥2 người
    if open>0 and playing>=CONFIG.FALLBACK_MIN then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > fbScore then fbScore = sc; bestFb = s end
    end

    -- 4) any open
    if open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > anyScore then anyScore = sc; bestAny = s end
    end
  end

  while tries < 60 do
    local page = (mode=="legacy") and fetch_legacy(cursor) or fetch_v1(cursor)
    if not page then mode=(mode=="legacy") and "v1" or "legacy"; tries+=1
    else
      for _,s in ipairs(page.data or {}) do consider(s) end
      if bestPref or (not page.nextPageCursor and (bestNear or bestFb or bestAny)) then break end
      cursor = page.nextPageCursor
      if not cursor then mode=(mode=="legacy") and "v1" or "legacy" end
      tries+=1
    end
  end

  if bestPref then return bestPref, "pref6/7" end
  if bestNear then return bestNear, "near(4-9)" end
  if bestFb   then return bestFb,   "fallback>=2" end
  return bestAny, "anyopen"
end

-- ====== Robust Teleport ======
local function try_teleport(jobId, reason)
  print(("[ServerHop] Calling Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP) end)
  if ok then return true end
  warn("[ServerHop] Teleport 3-arg error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP, nil, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Teleport 5-arg error: "..tostring(err))
  return false,err
end
local function try_random(reason)
  print(("[ServerHop] Random Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID, LP, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place,player,data) error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place) error: "..tostring(err))
  return false,err
end

-- ====== Hop core ======
local function save_and_carry()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end
  if queue_on_tp then local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end
end

local function hop_once(tag)
  if HOP_LOCK or PET_HOLD then return end
  HOP_LOCK=true; LOCK_AT=clk(); purge_old()

  local target, why = pick_server()
  if not target then
    warn("[ServerHop] Hết server phù hợp. Chờ rồi thử lại…")
    HOP_LOCK=false; return
  end

  LAST_TARGET_ID  = target.id
  LAST_ATTEMPT_AT = clk()
  save_and_carry()
  print(string.format("[ServerHop] Hopping to %s | players=%s (%s)", target.id, tostring(target.playing), tostring(why)))
  local okTeleport = try_teleport(target.id, why)
  if not okTeleport then HOP_LOCK=false; return end
end

TeleportService.TeleportInitFailed:Connect(function(plr, result, errMsg)
  if plr~=LP then return end
  warn("[ServerHop] Teleport failed: "..tostring(result).." | "..tostring(errMsg))
  if LAST_TARGET_ID then
    fail_cooldown[LAST_TARGET_ID]=now()
    if CONFIG.TEMP_BLACKLIST_ENABLED and CONFIG.TEMP_BLACKLIST_ON_FAIL then
      blacklist_add(LAST_TARGET_ID, "fail:"..tostring(result))
    end
  end
  CONSEC_FAILS += 1
  HOP_LOCK=false
  wait_range(CONFIG.RETRY_BACKOFF.min, CONFIG.RETRY_BACKOFF.max)

  if CONSEC_FAILS >= CONFIG.ESCALATE_AFTER_FAILS and not PET_HOLD then
    CONSEC_FAILS = 0
    try_random("escalate-fails")
  else
    hop_once("retry:"..tostring(result))
  end
end)

-- ====== Boot & loops ======
local function boot()
  load_blacklist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  load_persist()
end
local function safe(f) local ok,err=pcall(f); if not ok then warn("[ServerHop] init err: ",err) end end
safe(load_pet_names)
safe(boot)
save_blacklist()
save_persist()

task.defer(function() wait_range(CONFIG.HOP_DELAY_SEC.min, CONFIG.HOP_DELAY_SEC.max); hop_once("start") end)

task.spawn(function()
  local lastLoop, lastScan = clk(), 0
  while task.wait(0.25) do
    if (tick()-lastScan) >= CONFIG.PET_SCAN_INTERVAL then lastScan=tick(); update_pet_hold() end

    -- watchdog: mở khóa & thử ngay nếu kẹt
    if HOP_LOCK and (clk()-LOCK_AT) > CONFIG.LOCK_WATCHDOG then
      HOP_LOCK=false
      if LAST_TARGET_ID then fail_cooldown[LAST_TARGET_ID]=now() end
      print("[ServerHop] Watchdog: unlock stale lock → hop ngay")
      hop_once("watchdog")
    end

    -- escalate nếu kẹt quá lâu
    if not HOP_LOCK and not PET_HOLD and (clk()-LAST_ATTEMPT_AT) > CONFIG.STALL_TIMEOUT_SEC then
      CONSEC_FAILS = 0
      try_random("stall-timeout")
      LAST_ATTEMPT_AT = clk()
    end

    if not HOP_LOCK and not PET_HOLD and (clk()-lastLoop) >= CONFIG.LOOP_INTERVAL then
      lastLoop = clk()
      hop_once("loop")
    end
  end
end)

print(string.format("[ServerHop] Ready on PlaceId=%d | ưu tiên 6–7, né server 'VN', block server cũ, blacklist tạm 1h | cooldown %ds",
  TARGET_PLACE_ID, CONFIG.FAIL_COOLDOWN))

        end)
    else
        if finder_secret_20m_s_auto_thread then
            task.cancel(finder_secret_20m_s_auto_thread)
            finder_secret_20m_s_auto_thread = nil
        end
    end
end)
-- ======================================================


-- ===== Finder > finder secret 50m/s auto =====
local finder_secret_50m_s_auto_thread = nil
local finder_secret_50m_s_autoToggle = createToggle(contentTabs["Finder"], "finder secret 50m/s auto", "Auto finder", 3)
finder_secret_50m_s_autoToggle.SetCallback(function(state)
    if state then
        if finder_secret_50m_s_auto_thread then task.cancel(finder_secret_50m_s_auto_thread) end
        finder_secret_50m_s_auto_thread = task.spawn(function()
-- Server Hopper – Steal a Brainrot (smart + anti-VN + block-forever + 1h-temp-blacklist + escalate + pause-on-pet)
-- Game: https://www.roblox.com/games/109983668079237/Steal-a-Brainrot
local TARGET_PLACE_ID = 109983668079237

-- ====== PET LIST (mỗi dòng 1 tên; phần sau ":" chỉ là ghi chú, bỏ qua khi khớp) ======
local PET_LIST = [[
Graipuss Medussi: 10M/s-20m/s
La Grande Combinasion: 10M/s-300M/s
Los Combinasionas: 15M/s-400M/s
Nuclearo Dinossauro: 15M/s-300M/s
Los Hotspotsitos: 20M/s-400M/s
Garama and Madundung: 50M/s-2B/s
]]

-- ========= Services =========
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")

local LP     = Players.LocalPlayer
local JOB_ID = game.JobId

-- Executor helpers
local queue_on_tp = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
local has_file    = (typeof(isfile) == "function")
local read_file   = readfile
local write_file  = writefile
local del_file    = delfile

-- ========= CONFIG =========
local CONFIG = {
  AVOID_FULL        = true,
  HOP_DELAY_SEC     = {min=0.2, max=0.6},

  -- chọn phòng
  PREFERRED_COUNTS  = {6, 7},          -- ưu tiên tuyệt đối
  NEAR_TARGET       = 6.5,             -- điểm đích
  NEAR_WINDOW       = {min=4, max=9},  -- ưu tiên gần trong khung này
  FALLBACK_MIN      = 2,               -- fallback mềm: ≥2 người
  MIN_OPEN_SOFT     = 2,               -- thích phòng còn ≥2 slot

  -- né server có vẻ VN
  LOCALE = {
    avoid_vietnamese          = true,  -- bật né VN
    vn_ratio_threshold        = 0.40,  -- ≥40% tên giống VN → coi là VN
    prefer_higher_ping_ms     = 120,   -- >=120ms cộng nhẹ điểm (0 để tắt)
    penalty_if_vn             = 1000,  -- trừ điểm cực mạnh cho server VN
  },

  -- visited / lặp
  TTL_SECONDS       = 3*60*60,         -- sẽ override ở dưới nếu BLOCK_OLD_FOREVER=true
  MAX_REMEMBER      = 120000,          -- nhớ nhiều jobId để không lặp
  PERSIST_TO_DISK   = true,
  BLOCK_OLD_FOREVER = true,            -- 🔒 chặn vĩnh viễn server đã từng vào

  -- ==== BLACKLIST TẠM THỜI (1H) ====
  TEMP_BLACKLIST_ENABLED = true,       -- bật blacklist tạm
  TEMP_BLACKLIST_TTL     = 60*60,      -- 1 giờ
  TEMP_BLACKLIST_ON_FAIL = true,       -- tự động add server fail vào blacklist 1h

  -- retry & loop
  RETRY_BACKOFF     = {min=0.35, max=0.9},
  LOOP_INTERVAL     = 2.2,
  FAIL_COOLDOWN     = 5,

  -- anti-kẹt & escalate
  LOCK_WATCHDOG     = 3.0,
  ESCALATE_AFTER_FAILS = 6,            -- nhiều fail liên tiếp → Teleport(place)
  STALL_TIMEOUT_SEC    = 12,           -- kẹt lâu → Teleport(place)

  -- pet
  PET_SCAN_INTERVAL = 1.5,
  PET_CLEAR_GRACE   = 2.0,
}

if CONFIG.BLOCK_OLD_FOREVER then
  CONFIG.TTL_SECONDS = 10 * 365 * 24 * 60 * 60  -- 10 năm ≈ vĩnh viễn
end

-- ========= STATE =========
local visited, fail_cooldown = {}, {}
local VISITED_FILE = ("visited_%d.json"):format(TARGET_PLACE_ID)

-- BLACKLIST 1H
local tblack = {}  -- [jobId] = expiresAt (unix)
local TBLACK_FILE = ("blacklist_%d.json"):format(TARGET_PLACE_ID)

local HOP_LOCK, LOCK_AT = false, 0
local LAST_TARGET_ID, LAST_ATTEMPT_AT = nil, 0
local CONSEC_FAILS = 0

-- ========= Utils =========
local function now() return os.time() end
local function clk() return os.clock() end
local function jdecode(s) local ok,d=pcall(function()return HttpService:JSONDecode(s)end); if ok then return d end end
local function jencode(t) local ok,s=pcall(function()return HttpService:JSONEncode(t)end); if ok then return s end end
local function wait_range(a,b) task.wait(a + math.random()*(b-a)) end
local function on_cooldown(id) local t=fail_cooldown[id]; return t and (now()-t)<=CONFIG.FAIL_COOLDOWN end

local function http_get(url)
  local ok, body = pcall(game.HttpGet, game, url, true)
  if ok and body then return true, body end
  if syn and syn.request then
    local r = syn.request({Url=url, Method="GET"}); if r and r.StatusCode==200 then return true, r.Body end
  end
  if http_request then
    local r = http_request({Url=url, Method="GET"}); if r and (r.StatusCode==200 or r.StatusCode==0) then return true, (r.Body or r.body) end
  end
  return false
end

local function purge_old()
  local t=now()
  for id,ts in pairs(visited) do if type(ts)~="number" or (t-ts)>CONFIG.TTL_SECONDS then visited[id]=nil end end
  for id,ts in pairs(fail_cooldown) do if (t-ts)>CONFIG.FAIL_COOLDOWN then fail_cooldown[id]=nil end end
  -- purge blacklist hết hạn
  for id,exp in pairs(tblack) do if type(exp)~="number" or t>=exp then tblack[id]=nil end end
  -- cắt bớt visited nếu quá lớn (an toàn)
  local n=0 for _ in pairs(visited) do n+=1 end
  if n>CONFIG.MAX_REMEMBER then
    local drop=n-CONFIG.MAX_REMEMBER
    for k in pairs(visited) do visited[k]=nil; drop-=1; if drop<=0 then break end end
  end
end

-- ====== TeleportData & persist ======
local function get_tpdata()
  local out; pcall(function()
    local td=TeleportService:GetLocalPlayerTeleportData()
    if td==nil then out=nil
    elseif typeof(td)=="Instance" and td.ClassName=="TeleportOptions" then
      local ok,tbl=pcall(function()return td:GetTeleportData()end)
      if ok and type(tbl)=="table" then out=tbl end
    elseif type(td)=="table" then out=td end
  end); return out
end
local function merge_num_map(dst, src) if type(src)~="table" then return end; for k,v in pairs(src) do if type(k)=="string" and type(v)=="number" then dst[k]=v end end end

-- Reset visited nếu cần: đặt shared.RESET_VISITED = true trước khi chạy script
local function reset_visited()
  visited = {}
  pcall(function() if typeof(del_file)=="function" then del_file(VISITED_FILE) end end)
  print("[ServerHop] Đã reset danh sách server đã vào.")
end
if rawget(shared, "RESET_VISITED") then reset_visited(); shared.RESET_VISITED = nil end

-- Blacklist 1h helpers
local function save_blacklist()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(tblack); if s then pcall(write_file, TBLACK_FILE, s) end end
end
local function load_blacklist()
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(TBLACK_FILE) then
    local ok,raw=pcall(read_file, TBLACK_FILE)
    if ok and raw then local obj=jdecode(raw); if type(obj)=="table" then for k,v in pairs(obj) do if type(v)=="number" then tblack[k]=v end end end end
  end
end
local function blacklist_add(id, reason)
  if not CONFIG.TEMP_BLACKLIST_ENABLED or not id then return end
  tblack[id] = now() + CONFIG.TEMP_BLACKLIST_TTL
  print(("[ServerHop] 🛑 Blacklist 1h: %s (%s)"):format(tostring(id), tostring(reason or "")))
  save_blacklist()
end
local function is_blacklisted(id)
  if not CONFIG.TEMP_BLACKLIST_ENABLED then return false end
  local exp = tblack[id]
  return exp and now() < exp
end

-- Lệnh thủ công
if rawget(shared, "ADD_BLACKLIST") then
  local val = shared.ADD_BLACKLIST
  if type(val)=="string" then blacklist_add(val, "manual")
  elseif type(val)=="table" then for _,jid in ipairs(val) do blacklist_add(tostring(jid), "manual") end end
  shared.ADD_BLACKLIST = nil
end
if rawget(shared, "RESET_BLACKLIST") then
  tblack = {}
  pcall(function() if typeof(del_file)=="function" then del_file(TBLACK_FILE) end end)
  print("[ServerHop] Đã reset blacklist tạm (1h).")
  shared.RESET_BLACKLIST = nil
end

local function save_persist() if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end end
local function load_persist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  if CONFIG.PERSIST_TO_DISK and has_file and isfile(VISITED_FILE) then local ok,raw=pcall(read_file,VISITED_FILE); if ok and raw then merge_num_map(visited, jdecode(raw) or {}) end end
  if rawget(shared,"__HOP_CARRY") then local c=shared.__HOP_CARRY; if c.visited then merge_num_map(visited,c.visited) end end
  visited[JOB_ID]=now(); purge_old()
end
local function carry_on_tp() if not queue_on_tp then return end; local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end

-- ====== Fetch servers ======
local function fetch_v1(cursor)
  local url=("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s"):format(TARGET_PLACE_ID, cursor and ("&cursor="..HttpService:UrlEncode(cursor)) or "")
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj then return nil end
  return obj
end

local function fetch_legacy(startindex)
  startindex=tonumber(startindex) or 0
  local url=("https://www.roblox.com/games/getgameinstancesjson?placeId=%d&startindex=%d"):format(TARGET_PLACE_ID, startindex)
  local ok,body=http_get(url); if not ok then return nil end
  local obj=jdecode(body); if not obj or not obj.Collection then return nil end
  local data={}
  for _,v in ipairs(obj.Collection) do
    local players = {}
    if type(v.CurrentPlayers)=="table" then
      for _,p in ipairs(v.CurrentPlayers) do
        table.insert(players, {username=tostring(p.Username or ""), display=tostring(p.DisplayName or "")})
      end
    end
    table.insert(data, {
      id = v.Guid,
      maxPlayers = v.Capacity,
      playing = v.CurrentPlayers and #v.CurrentPlayers or v.CurrentPlayers or 0,
      ping = tonumber(v.Ping),
      players = players
    })
  end
  return { data = data, nextPageCursor = (#data==0) and nil or tostring(startindex+10) }
end

-- ====== Anti-VN heuristic ======
local VIET_CHARS_PATTERN = "[àáạảãâầấậẩẫ ăằắặẳẵèéẹẻẽêềếệểễ ìíịỉĩ òóọỏõôồốộổỗơờớợởỡ ùúụủũưừứựửữ ỳýỵỷỹ đĐ]"
local VN_KEYWORDS = {" viet", " việt", " vn", " nguyen", " trần", " tran ", " lê ", " le ", " pham ", " phạm ", " ngoc ", " minh "}
local function looks_vietnamese(s)
  s = " "..string.lower(s or "").." "
  if s:find(VIET_CHARS_PATTERN) then return true end
  for _,kw in ipairs(VN_KEYWORDS) do if s:find(kw, 1, true) then return true end end
  return false
end
local function vn_ratio(players)
  if not players or #players==0 then return 0 end
  local vn, total = 0, 0
  for _,p in ipairs(players) do
    total += 1
    if looks_vietnamese(p.display) or looks_vietnamese(p.username) then vn += 1 end
  end
  return vn/total
end

-- ====== Pets ======
local PET_NAMES, PET_HOLD, PET_LAST_SEEN, PET_LAST_FOUND_LIST = {}, false, 0, {}
local function normalize_pet_list(text)
  local set = {}
  for raw in tostring(text):gmatch("[^\r\n]+") do
    local line = raw:gsub("^%s+",""):gsub("%s+$","")
    if line~="" and not line:match("^%-%-") then
      local nameOnly = line:match("^(.-):") or line
      nameOnly = nameOnly:gsub("%s+$","")
      set[string.lower(nameOnly)] = true
    end
  end
  return set
end
local function load_pet_names()
  local set = normalize_pet_list(PET_LIST or "")
  if has_file and isfile("pets_list.txt") then local ok,raw=pcall(read_file,"pets_list.txt"); if ok and raw then for k,_ in pairs(normalize_pet_list(raw)) do set[k]=true end end end
  PET_NAMES=set
end
local function name_hit(sLower) for want,_ in pairs(PET_NAMES) do if sLower:find(want,1,true) then return want end end end
local function scan_for_pets()
  if next(PET_NAMES)==nil then return false,{} end
  local found,matched=false,{}
  for _,plr in ipairs(Players:GetPlayers()) do
    local ch=plr.Character
    if ch then
      for _,inst in ipairs(ch:GetDescendants()) do
        local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
        if inst:IsA("StringValue") then local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end end
      end
    end
    local bp=plr:FindFirstChildOfClass("Backpack")
    if bp then for _,inst in ipairs(bp:GetDescendants()) do local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end end end
  end
  for _,inst in ipairs(workspace:GetDescendants()) do
    if inst:IsA("Model") or inst:IsA("Folder") or inst:IsA("Accessory") or inst:IsA("Tool") then
      local nm=string.lower(inst.Name or ""); local hit=name_hit(nm); if hit then found=true; matched[hit]=true end
    elseif inst:IsA("StringValue") then
      local v=string.lower(tostring(inst.Value or "")); local h2=name_hit(v); if h2 then found=true; matched[h2]=true end
    end
  end
  return found,matched
end
local function update_pet_hold()
  local ok,matched=scan_for_pets(); local tnow=tick()
  if ok then
    PET_LAST_SEEN=tnow
    if not PET_HOLD then PET_HOLD=true; PET_LAST_FOUND_LIST={}; for k,_ in pairs(matched) do table.insert(PET_LAST_FOUND_LIST,k) end; print("[ServerHop] ▶️ gặp PET → dừng:", table.concat(PET_LAST_FOUND_LIST,", ")) end
  elseif PET_HOLD and (tnow-PET_LAST_SEEN)>=CONFIG.PET_CLEAR_GRACE then PET_HOLD=false; print("[ServerHop] ⏩ pet hết → tiếp tục") end
end

-- ====== Smart picker (ưu tiên nước ngoài + tôn trọng blacklist) ======
local function in_pref(n) for _,v in ipairs(CONFIG.PREFERRED_COUNTS) do if n==v then return true end end end
local function pick_server()
  local bestPref, bestNear, bestFb, bestAny = nil, nil, nil, nil
  local nearScore, fbScore, anyScore = -1e12, -1e12, -1e12
  local cursor, tries, mode = nil, 0, "legacy"  -- bắt đầu bằng legacy để có players/ping

  local function consider(s)
    local id=s.id; local playing=tonumber(s.playing) or 0; local cap=tonumber(s.maxPlayers) or 100
    local open=cap-playing
    if id==JOB_ID or visited[id] or on_cooldown(id) or (CONFIG.TEMP_BLACKLIST_ENABLED and is_blacklisted(id)) then return end
    if CONFIG.AVOID_FULL and open<=0 then return end

    local vr = s.players and vn_ratio(s.players) or 0
    local isVN = CONFIG.LOCALE.avoid_vietnamese and (vr >= CONFIG.LOCALE.vn_ratio_threshold)
    local vnPenalty = isVN and CONFIG.LOCALE.penalty_if_vn or 0
    local openPenalty = (open < CONFIG.MIN_OPEN_SOFT) and 2 or 0
    local pingBonus = (s.ping and CONFIG.LOCALE.prefer_higher_ping_ms>0 and s.ping >= CONFIG.LOCALE.prefer_higher_ping_ms) and 0.5 or 0

    -- 1) exact 6/7
    if in_pref(playing) and open>0 then
      local sc = 10000 - open*0.01 - vnPenalty + pingBonus
      if not bestPref or sc > (10000 - 0.01) then bestPref = s end
    end

    -- 2) gần 6.5 trong [4..9]
    if playing>=CONFIG.NEAR_WINDOW.min and playing<=CONFIG.NEAR_WINDOW.max and open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - open*0.001 - vnPenalty + pingBonus
      if sc > nearScore then nearScore = sc; bestNear = s end
    end

    -- 3) fallback ≥2 người
    if open>0 and playing>=CONFIG.FALLBACK_MIN then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > fbScore then fbScore = sc; bestFb = s end
    end

    -- 4) any open
    if open>0 then
      local sc = -math.abs(playing - CONFIG.NEAR_TARGET) - openPenalty - vnPenalty + pingBonus
      if sc > anyScore then anyScore = sc; bestAny = s end
    end
  end

  while tries < 60 do
    local page = (mode=="legacy") and fetch_legacy(cursor) or fetch_v1(cursor)
    if not page then mode=(mode=="legacy") and "v1" or "legacy"; tries+=1
    else
      for _,s in ipairs(page.data or {}) do consider(s) end
      if bestPref or (not page.nextPageCursor and (bestNear or bestFb or bestAny)) then break end
      cursor = page.nextPageCursor
      if not cursor then mode=(mode=="legacy") and "v1" or "legacy" end
      tries+=1
    end
  end

  if bestPref then return bestPref, "pref6/7" end
  if bestNear then return bestNear, "near(4-9)" end
  if bestFb   then return bestFb,   "fallback>=2" end
  return bestAny, "anyopen"
end

-- ====== Robust Teleport ======
local function try_teleport(jobId, reason)
  print(("[ServerHop] Calling Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP) end)
  if ok then return true end
  warn("[ServerHop] Teleport 3-arg error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, jobId, LP, nil, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Teleport 5-arg error: "..tostring(err))
  return false,err
end
local function try_random(reason)
  print(("[ServerHop] Random Teleport (reason=%s)"):format(reason or "?"))
  local ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID, LP, {visited=visited}) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place,player,data) error: "..tostring(err))
  task.wait(0.05)
  ok,err=pcall(function() TeleportService:Teleport(TARGET_PLACE_ID) end)
  if ok then return true end
  warn("[ServerHop] Random Teleport(place) error: "..tostring(err))
  return false,err
end

-- ====== Hop core ======
local function save_and_carry()
  if CONFIG.PERSIST_TO_DISK and write_file then local s=jencode(visited); if s then pcall(write_file,VISITED_FILE,s) end end
  if queue_on_tp then local blob=jencode(visited) or "{}"; pcall(queue_on_tp, ([[shared.__HOP_CARRY={visited=%s}]]):format(blob)) end
end

local function hop_once(tag)
  if HOP_LOCK or PET_HOLD then return end
  HOP_LOCK=true; LOCK_AT=clk(); purge_old()

  local target, why = pick_server()
  if not target then
    warn("[ServerHop] Hết server phù hợp. Chờ rồi thử lại…")
    HOP_LOCK=false; return
  end

  LAST_TARGET_ID  = target.id
  LAST_ATTEMPT_AT = clk()
  save_and_carry()
  print(string.format("[ServerHop] Hopping to %s | players=%s (%s)", target.id, tostring(target.playing), tostring(why)))
  local okTeleport = try_teleport(target.id, why)
  if not okTeleport then HOP_LOCK=false; return end
end

TeleportService.TeleportInitFailed:Connect(function(plr, result, errMsg)
  if plr~=LP then return end
  warn("[ServerHop] Teleport failed: "..tostring(result).." | "..tostring(errMsg))
  if LAST_TARGET_ID then
    fail_cooldown[LAST_TARGET_ID]=now()
    if CONFIG.TEMP_BLACKLIST_ENABLED and CONFIG.TEMP_BLACKLIST_ON_FAIL then
      blacklist_add(LAST_TARGET_ID, "fail:"..tostring(result))
    end
  end
  CONSEC_FAILS += 1
  HOP_LOCK=false
  wait_range(CONFIG.RETRY_BACKOFF.min, CONFIG.RETRY_BACKOFF.max)

  if CONSEC_FAILS >= CONFIG.ESCALATE_AFTER_FAILS and not PET_HOLD then
    CONSEC_FAILS = 0
    try_random("escalate-fails")
  else
    hop_once("retry:"..tostring(result))
  end
end)

-- ====== Boot & loops ======
local function boot()
  load_blacklist()
  local td=get_tpdata(); if td and td.visited then merge_num_map(visited,td.visited) end
  load_persist()
end
local function safe(f) local ok,err=pcall(f); if not ok then warn("[ServerHop] init err: ",err) end end
safe(load_pet_names)
safe(boot)
save_blacklist()
save_persist()

task.defer(function() wait_range(CONFIG.HOP_DELAY_SEC.min, CONFIG.HOP_DELAY_SEC.max); hop_once("start") end)

task.spawn(function()
  local lastLoop, lastScan = clk(), 0
  while task.wait(0.25) do
    if (tick()-lastScan) >= CONFIG.PET_SCAN_INTERVAL then lastScan=tick(); update_pet_hold() end

    -- watchdog: mở khóa & thử ngay nếu kẹt
    if HOP_LOCK and (clk()-LOCK_AT) > CONFIG.LOCK_WATCHDOG then
      HOP_LOCK=false
      if LAST_TARGET_ID then fail_cooldown[LAST_TARGET_ID]=now() end
      print("[ServerHop] Watchdog: unlock stale lock → hop ngay")
      hop_once("watchdog")
    end

    -- escalate nếu kẹt quá lâu
    if not HOP_LOCK and not PET_HOLD and (clk()-LAST_ATTEMPT_AT) > CONFIG.STALL_TIMEOUT_SEC then
      CONSEC_FAILS = 0
      try_random("stall-timeout")
      LAST_ATTEMPT_AT = clk()
    end

    if not HOP_LOCK and not PET_HOLD and (clk()-lastLoop) >= CONFIG.LOOP_INTERVAL then
      lastLoop = clk()
      hop_once("loop")
    end
  end
end)

print(string.format("[ServerHop] Ready on PlaceId=%d | ưu tiên 6–7, né server 'VN', block server cũ, blacklist tạm 1h | cooldown %ds",
  TARGET_PLACE_ID, CONFIG.FAIL_COOLDOWN))

        end)
    else
        if finder_secret_50m_s_auto_thread then
            task.cancel(finder_secret_50m_s_auto_thread)
            finder_secret_50m_s_auto_thread = nil
        end
    end
end)
-- ======================================================
